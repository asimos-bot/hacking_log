# 64 bit ROP

dependencies:
[Basics of ROP](first.md)

sources:
https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details
https://www.ret2rop.com/2018/08/return-to-libc.html

After seeing how do on 32 bit archtecture, we are ready to move on to
64 bit ROP!

This section will prove to be more challeging, but also more rewarding,
since we are moving closer and closer to understand how these attacks
are normally performed in modern applications.

## Second Easiest Scenario

### The Compilation

For this section we will use the rule `second` in the `Makefile`. to use
just type `make second` or do it manually with:

```
gcc rip.c -fno-stack-protector -o rip
```

And disable ASLR with:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

## Major Differences

What do we need to watch out when doing a 64 bit ROP exploitation for the
first time?

#### Addresses

In 64 bit the addresses are 64 bit wide, just like 32 bit architecture had
32 bit addresses. However, since 64 bit provide an enourmous number of
possible addresses, only 48 bytes are actually used (already enough to 
address 256 terabytes!).

That means only addresses from `0x0000 0000 0000 0000` to `0x0000 7fff ffff ffff`
are actually used, which force us to always deal with two null bytes everytime we
handle an address.

#### Arguments

In 64 bits most arguments are passed through registers. We will need to somehow
load the desired arguments to a function to the right registers before calling
a function.

#### Offset

Since we are not using the `-no-pie` option, our binary will contain function
independent code, which means `objdump` and other static analysis tools
won't be able to show us the exact addresses that will be used be the binary.

This is easy to overcome since we are still using ASLR and we can just see
what addresses are used in GDB when the program is loaded.
