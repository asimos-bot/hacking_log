# Assembly Basics

sources:
http://www.cs.virginia.edu/~evans/cs216/guides/x86.html \
https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction \
http://ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html \
https://www.ibm.com/developerworks/rational/library/inline-assembly-c-cpp-guide/index.html \
https://www.ibm.com/developerworks/library/l-ia/index.html

NOTE: based on the intel flavor syntax (`set disassembly-flavor intel`)

## Square Brackets

To get a value in an address use square brackets ([]) to deference it.

`push DWORD PTR [ecx-0x4]`

To reference a space in memory too:

`mov DWORD PTR [ebp-0xc], 0x1`

## Memory Size

When we are dealing with values in a given address, we should say how much
memory we are manipulating.

For example:

`mov DWORD PTR [ebp-0xc], 0x1`

If we just had `mov [ebp-0xc], 0x1` there would be no way to know how much
space in memory `0x1` should occupy. If it is 1 byte, we should write
7 zeros and then a 1, if it is 2 bytes we should write 8 zeros in the
next byte (ebp-0xb) and then 7 zeros and a 1 in ebp-0xc.

The syntax is the following:

* BYTE - 8 bits, 1 byte
* WORD - 16 bits, 2 byte
* DWORD - 32 bits, 4 byte
* QWORD - 64 bits, 8 byte

## Commands

A list with a short description of some common assembly commands:

* `push` - write the given value to the top of the stack, decrementing the
Stack Pointer (since the stack grows downwards)

* `pop` - take out the value from the top of the stack and write it to
the given operand, incrementing the Stack Pointer (since the stack growns
downwards)

* `lea` - (load effective address) give the address of the right argument
to the left argument. So when the right argument is an address that is
being deferenced by square brackets, it will be referenced again by `lea`
and the address wil be given to the left argument.

* `mov` - give the value at the right argument to the left argument. If one
of the arguments is an address in square brackets, the size of the memory
to be copied from the address should be given by "<size> PTR" before the
reference. `size` can have the values shown in the
[Memory Size](#memory-size) section.

* `cmp` and `jmp` - `cmp` takes two operands and subtract their values,
without changing them, to compare them (setting some status flag). `jmp`
is just an unconditional jump to another part of the code, but is
variations, like `je`, `jne` and `jg` (there are orders) check the status
flags to decide to make a jump or not. Every `jmp`-like command takes in
one argument, which is the address they will jump to if conditions are met.

* `call` - `push` the address of the next instruction to be called in the
current function to the stack and change RIP/EIP value to the argument
given to it.

* `leave` - copy the value of RBP/EBP to RSP/ESP (shrinks stack to nothing)
and then `pop` to RBP/EBP.

* `ret` - `pop` to RIP/EIP. Called at the end of a function.

## Starting To Write With Inline Assembly

The easiest way to start writing assembly is probably through inline
assembly in C/C++.

GCC allow us to inject some assembly code in the middle of our normal
C/C++ code.

Instead of writing your entire program in assembly, you can just
write part of a function with it.

### GCC Assembler Syntax

GCC uses the AT&T syntax, which can is different from the intel syntax
we normally use here.

### Basic Example

```
asm("movl %ecx %eax"); /* moves the contents of ecx to eax */
__asm__("movl %ecx %eax"); /* also moves the contents of ecx to eax */
```

As you can see, in GCC we can use both `asm` and `__asm__` to start
inlining the code, which is passed as a string.

### Volatile

You have seen some code like this in the wild:

```
asm volatile (" ... rest of the code ...
```

What is this `volatile` keyword? It is used to tell the compiler
to don't move this code elsewhere in an attempt to optimize it. It
can be useful when you want your assembly code to execute exactly
as you have written it, but would better not be used if you are
using assembly to optimize some heavy calculations.

### Outputs, Inputs and Clobbers

Let's look at a more complicated example:

```
int res=0;
int op1=20;
int op2=30;
 
 asm ( " addc.    %0,%1,%2\n"         
        : "=r"(res)                       
	: "b"(op1), "r"(op2)                    
	: "r0"                    );
```

The code aboves add `op1` to `op2` and write the result to `res`.

After the initial string with the instructions, we can colons
(`:`) to give other types of arguments: outputs, inputs and
clobbers (in that order).

Let's analyze this code line by line:

1. `" addc.    %0,%1,%2\n"`  - The assembly code that will executed.
The `%n` syntax is used to refer to the registers using the order they
are passed to the `asm` block.

2. `: "=r"(res)` - The colon tell us this is where the output of the
`asm` block will be stored. The `r` is used to add a constraint and
the `=` is a constraint modifier. The `r` constraint tells GCC that it
can use any general purpose register it wants for this variable.

3. `: "b"(op1), "r"(op2)` - These are the inputs. Just like before,
the string that comes before a variable name indicate the contraints
(`"b"` and `"r"`).

4. `: "r0"` - In this assembly code, this register (`r0`) is not used,
so this line doesn't make a difference. However, if we used registers
that were not associated with a variable, we would need to list them
here. This is done to notify the compiler that these registers could have
their values changed. When writing register names in the first line of the
`asm` block, use double `%`, like `%%eax`, (not needed in other lines,
like in the clobbered list, you can even use no `%`) to help the compiler
better distinguish between variable index and register name.

### Constraints

What are these constraints we talked about? Each one has a different meaning:

Constraint | Effect |
-----------|--------|
"r"        | GCC can use any General Purpose Register for this variable.
"m"        | Any operations done in the register will instead affect the variable directly.
"a"        | Used when a variable is both written and read. Need to specify location of variable in the output section when writing the input (row below). Only `eax` type registers can be used for this.
"<digit>"  | Reference a variable. Used in input section after "a" is used for the same variable in output section.
"b"        | Only `ebx` type registers can be used for this variable.
"c"        | Only `ecx` type registers can be used for this variable.
"d"        | Only `edx` type registers can be used for this variable.
"S"        | Only `esi` type registers can be used for this variable.
"D"        | Only `edi` type registers can be used for this variable.
"i"        | An immediate integer operand (one with constant value) is allowed. This includes symbolic constants whose values will be known only at assembly time or later.

The list is non-exhaustive. There are some contraints available only for
x86 (32 bits) and with other affects.

#### Contraint Modifiers

We can also use constraint modifiers:

Constraint Modifier | Effect |
--------------------|--------|
"="                 | This operand is write-only for this block. The previous value is discarded and replaced with output data.
"+"                 | Means that the operand is both read and write by the instruction.
